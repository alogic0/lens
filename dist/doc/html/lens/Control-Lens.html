<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Control.Lens</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Control-Lens.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Control-Lens.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">lens-4.12.2: Lenses, Folds and Traversals</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Copyright</th><td>(C) 2012-15 Edward Kmett</td></tr><tr><th>License</th><td>BSD-style (see the file LICENSE)</td></tr><tr><th>Maintainer</th><td>Edward Kmett &lt;ekmett@gmail.com&gt;</td></tr><tr><th>Stability</th><td>experimental</td></tr><tr><th>Portability</th><td>non-portable</td></tr><tr><th>Safe Haskell</th><td>Safe</td></tr><tr><th>Language</th><td>Haskell98</td></tr></table><p class="caption">Control.Lens</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Tutorial</a></li><li><a href="#g:2">Motivation</a></li><li><a href="#g:3">Lenses</a></li><li><a href="#g:4">Accessor notation</a></li><li><a href="#g:5">First-class</a></li><li><a href="#g:6">Traversals</a></li><li><a href="#g:7">Types</a></li><li><a href="#g:8">Drawbacks</a></li><li><a href="#g:9">Conclusion</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Usage:</p><p>You can derive lenses automatically for many data types:</p><pre>import Control.Lens

data FooBar a
  = Foo { _x :: [<code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Int.html#t:Int">Int</a></code>], _y :: a }
  | Bar { _x :: [<code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Int.html#t:Int">Int</a></code>] }
<code><a href="Control-Lens-TH.html#v:makeLenses">makeLenses</a></code> ''FooBar
</pre><p>This defines the following lenses:</p><pre>x :: <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> (FooBar a) [<code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Int.html#t:Int">Int</a></code>]
y :: <code><a href="Control-Lens-Type.html#t:Traversal">Traversal</a></code> (FooBar a) (FooBar b) a b
</pre><p>You can then access the value of <code>_x</code> with (<code><a href="Control-Lens-Getter.html#v:-94-.">^.</a></code>), the value of <code>_y</code> &#8211;
 with (<code><a href="Control-Lens-Fold.html#v:-94--63-">^?</a></code>) or (<code><a href="Control-Lens-Fold.html#v:-94--63--33-">^?!</a></code>) (since it can fail), set the values with (<code><a href="Control-Lens-Setter.html#v:.-126-">.~</a></code>),
 modify them with (<code><a href="Control-Lens-Setter.html#v:-37--126-">%~</a></code>), and use almost any other combinator that is
 re-exported here on those fields.</p><p>The combinators here have unusually specific type signatures, so for
 particularly tricky ones, the simpler type signatures you might want to
 pretend the combinators have are specified as well.</p><p>More information on how to use lenses is available on the lens wiki:</p><p><a href="http://github.com/ekmett/lens/wiki">http://github.com/ekmett/lens/wiki</a></p><p><img src="Hierarchy.png" /></p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short">module <a href="Control-Lens-At.html">Control.Lens.At</a></li><li class="src short">module <a href="Control-Lens-Cons.html">Control.Lens.Cons</a></li><li class="src short">module <a href="Control-Lens-Each.html">Control.Lens.Each</a></li><li class="src short">module <a href="Control-Lens-Empty.html">Control.Lens.Empty</a></li><li class="src short">module <a href="Control-Lens-Equality.html">Control.Lens.Equality</a></li><li class="src short">module <a href="Control-Lens-Fold.html">Control.Lens.Fold</a></li><li class="src short">module <a href="Control-Lens-Getter.html">Control.Lens.Getter</a></li><li class="src short">module <a href="Control-Lens-Indexed.html">Control.Lens.Indexed</a></li><li class="src short">module <a href="Control-Lens-Iso.html">Control.Lens.Iso</a></li><li class="src short">module <a href="Control-Lens-Lens.html">Control.Lens.Lens</a></li><li class="src short">module <a href="Control-Lens-Level.html">Control.Lens.Level</a></li><li class="src short">module <a href="Control-Lens-Plated.html">Control.Lens.Plated</a></li><li class="src short">module <a href="Control-Lens-Prism.html">Control.Lens.Prism</a></li><li class="src short">module <a href="Control-Lens-Reified.html">Control.Lens.Reified</a></li><li class="src short">module <a href="Control-Lens-Review.html">Control.Lens.Review</a></li><li class="src short">module <a href="Control-Lens-Setter.html">Control.Lens.Setter</a></li><li class="src short">module <a href="Control-Lens-TH.html">Control.Lens.TH</a></li><li class="src short">module <a href="Control-Lens-Traversal.html">Control.Lens.Traversal</a></li><li class="src short">module <a href="Control-Lens-Tuple.html">Control.Lens.Tuple</a></li><li class="src short">module <a href="Control-Lens-Type.html">Control.Lens.Type</a></li><li class="src short">module <a href="Control-Lens-Wrapped.html">Control.Lens.Wrapped</a></li><li class="src short">module <a href="Control-Lens-Zoom.html">Control.Lens.Zoom</a></li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src">module <a href="Control-Lens-At.html">Control.Lens.At</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Cons.html">Control.Lens.Cons</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Each.html">Control.Lens.Each</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Empty.html">Control.Lens.Empty</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Equality.html">Control.Lens.Equality</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Fold.html">Control.Lens.Fold</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Getter.html">Control.Lens.Getter</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Indexed.html">Control.Lens.Indexed</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Iso.html">Control.Lens.Iso</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Lens.html">Control.Lens.Lens</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Level.html">Control.Lens.Level</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Plated.html">Control.Lens.Plated</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Prism.html">Control.Lens.Prism</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Reified.html">Control.Lens.Reified</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Review.html">Control.Lens.Review</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Setter.html">Control.Lens.Setter</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-TH.html">Control.Lens.TH</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Traversal.html">Control.Lens.Traversal</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Tuple.html">Control.Lens.Tuple</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Type.html">Control.Lens.Type</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Wrapped.html">Control.Lens.Wrapped</a></p></div><div class="top"><p class="src">module <a href="Control-Lens-Zoom.html">Control.Lens.Zoom</a></p></div><h1 id="g:1">Tutorial</h1><div class="doc"><p>This <code>lens</code> tutorial targets Haskell beginners and assumes only basic
    familiarity with Haskell.  By the end of this tutorial you should:</p><ul><li><p>understand what problems the <code>lens</code> library solves,</p><ul><li>know when it is appropriate to use the <code>lens</code> library,</li><li>be proficient in the most common <code>lens</code> idioms,</li><li>understand the drawbacks of using lenses, and:</li><li>know where to look if you wish to learn more advanced tricks.</li></ul></li></ul></div><h1 id="g:2">Motivation</h1><div class="doc"><p>The simplest problem that the <code>lens</code> library solves is updating deeply
     nested records.  Suppose you had the following nested Haskell data types:</p><pre>data Atom = Atom { _element :: String, _point :: Point }

data Point = Point { _x :: Double, _y :: Double }</pre><p>If you wanted to increase the <code>x</code> coordinate of an <code>Atom</code> by one unit, you
     would have to write something like this in Haskell:</p><pre>shiftAtomX :: Atom -&gt; Atom
shiftAtomX (Atom e (Point x y)) = Atom e (Point (x + 1) y)</pre><p>This unpacking and repacking of data types grows increasingly difficult the
     more fields you add to each data type or the more deeply nested your data
     structures become.</p><p>The <code>lens</code> library solves this problem by letting you instead write:</p><pre>-- atom.hs

{-# LANGUAGE TemplateHaskell #-}

import Control.Lens hiding (element)

data Atom = Atom { _element :: String, _point :: Point } deriving (Show)

data Point = Point { _x :: Double, _y :: Double } deriving (Show)

makeLenses ''Atom
makeLenses ''Point

shiftAtomX :: Atom -&gt; Atom
shiftAtomX = over (point . x) (+ 1)</pre><p>Let's convince ourselves that this works:</p><pre>&gt;&gt;&gt; :load atom.hs
&gt;&gt;&gt; let atom = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
&gt;&gt;&gt; shiftAtomX atom
Atom {_element = &quot;C&quot;, _point = Point {_x = 2.0, _y = 2.0}}</pre><p>The above solution does not change no matter how many fields we add to
     <code>Atom</code> or <code>Point</code>.</p><p>Now suppose that we added yet another data structure:</p><pre>data Molecule = Molecule { _atoms :: [Atom] } deriving (Show)</pre><p>We could shift an entire <code>Molecule</code> by writing:</p><pre>makeLenses ''Molecule

shiftMoleculeX :: Molecule -&gt; Molecule
shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)</pre><p>Again, this works the way we expect:</p><pre>&gt;&gt;&gt; :load atom.hs
&gt;&gt;&gt; let atom1 = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
&gt;&gt;&gt; let atom2 = Atom { _element = &quot;O&quot;, _point = Point { _x = 3.0, _y = 4.0 } }
&gt;&gt;&gt; let molecule = Molecule { _atoms = [atom1, atom2] }
&gt;&gt;&gt; shiftMoleculeX molecule  -- Output formatted for clarity
Molecule
    { _atoms =
        [ Atom { _element = &quot;C&quot;, _point = Point { _x = 2.0, _y = 2.0 } }
        , Atom { _element = &quot;)&quot;, _point = Point { _x = 4.0, _y = 4.0 } }
        ]
    }</pre><p>Many people stumble across lenses while trying to solve this common problem
     of working with data structures with a large number of fields or deeply
     nested values.  These sorts of situations arise commonly in:</p><ul><li>games with complex and deeply nested state</li><li>scientific data formats</li><li>sensor or instrument output</li><li>web APIs</li><li>XML and JSON</li><li>enterprise code where data structures can have tens, hundreds, or even
       thousands of fields (true story!)</li></ul></div><h1 id="g:3">Lenses</h1><div class="doc"><p>You might have some basic questions like:</p><p><em>Question:</em> What is a lens?</p><p><em>Answer:</em> A lens is a first class getter and setter</p><p>We already saw how to use lenses to update values using <code><a href="Control-Lens-Setter.html#v:over">over</a></code>, but we can
    also use lenses to retrieve values using <code><a href="Control-Lens-Getter.html#v:view">view</a></code>:</p><pre>&gt;&gt;&gt; :load atom.hs
&gt;&gt;&gt; let atom = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
&gt;&gt;&gt; view (point . x) atom
1</pre><p>In other words, lenses package both &quot;get&quot; and &quot;set&quot; functionality into
    a single value (the lens).  You could pretend that a lens is a record
    with two fields:</p><pre>data Lens a b = Lens
    { view :: a -&gt; b
    , over :: (b -&gt; b) -&gt; (a -&gt; a)
    }</pre><p>That's not how lenses are actually implemented, but it's a useful
    starting intuition.</p><p><em>Question:</em> What is the type of a lens?</p><p><em>Answer:</em> We used two lenses in the above <code>Atom</code> example, with these types:</p><pre>point :: Lens' Atom  Point
x     :: Lens' Point Double</pre><p>The <code>point</code> lens contains all the information we need to get or set the
    <code>_point</code> field of the <code>Atom</code> type (which is a <code>Point</code>).  Similarly, the <code>x</code>
    lens contains all the information we need to get or set the <code>_x</code> field of
    the <code>Point</code> data type (which is a <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/GHC-Exts.html#t:Double">Double</a></code>).</p><p>The convention for the <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> type parameters is:</p><pre>--    +-- Bigger type
--    |
--    v
Lens' bigger smaller
--           ^
--           |
--           +--  Smaller type within the bigger type</pre><p>The actual definition of <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> is:</p><pre>type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>You might wonder how you can fit both getter and setter functionality in
    a single value like this.  The trick is that we get to pick what <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code>
    we specialize <code>f</code> to and depending on which <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code> we pick we get
    different features.</p><p>For example, if you pick <code>(f = <code><a href="Control-Lens-Setter.html#t:Identity">Identity</a></code>)</code>:</p><pre>type ASetter' a b   = (b -&gt; Identity b) -&gt; (a -&gt; Identity a)

-- ... equivalent to: (b -&gt;          b) -&gt; (a -&gt;          a)</pre><p>... you can build an <code><a href="Control-Lens-Setter.html#v:over">over</a></code>-like function.</p><p>Similarly, if you pick <code>(f = <code><a href="Control-Lens-Getter.html#t:Const">Const</a></code> b)</code>:</p><pre>type Getting b a b  = (b -&gt; Const b b) -&gt; (a -&gt; Const b b)

-- ... equivalent to: (b -&gt;       b  ) -&gt; (a -&gt;       b  )

-- ... equivalent to:                     (a -&gt;       b  )</pre><p>... you can build a <code><a href="Control-Lens-Getter.html#v:view">view</a></code>-like function.</p><p>Those are not the only two <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code>s we can pick.  In fact, we can do a
    lot more with lenses than just get and set values, but those are the two
    most commonly used features.</p><p><em>Question:</em> How do I create lenses?</p><p><em>Answer:</em> You can either auto-generate them using Template Haskell or
    create them by hand</p><p>In our <code>Atom</code> example, we auto-generated the lenses using Template Haskell,
    like this:</p><pre>makeLenses ''Atom
makeLenses ''Point</pre><p>This created four lenses of the following types:</p><pre>element :: Lens' Atom String
point   :: Lens' Atom Point
x       :: Lens' Point Double
y       :: Lens' Point Double</pre><p><code><a href="Control-Lens-TH.html#v:makeLenses">makeLenses</a></code> creates one lens per field prefixed with an underscore.  The
    lens has the same name as the field without the underscore.</p><p>However, sometimes Template Haskell is not an option, so we can also use
    the <code><a href="Control-Lens-Lens.html#v:lens">lens</a></code> utility function to build lenses.  This utility has type:</p><pre>lens :: (a -&gt; b) -&gt; (b -&gt; a -&gt; a) -&gt; Lens' a b</pre><p>The first argument is a &quot;getter&quot; (a way to extract a <code>'b'</code> from an
    <code>'a'</code>).  The second argument is a &quot;setter&quot; (given a <code>b</code>, update an
    <code>a</code>).  The result is a <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> built from the getter and setter.  You would
    use <code><a href="Control-Lens-Lens.html#v:lens">lens</a></code> like this:</p><pre>point :: Lens' Atom Point
point = lens _point (\newPoint atom -&gt; atom { _point = newPoint })</pre><p>You can even define lenses without incurring a dependency on the <code>lens</code>
    library.  Remember that lenses are just higher-order functions over
    <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code>s, so we could instead write:</p><pre>-- point :: Lens' Atom Point
point :: Functor f =&gt; (Point -&gt; f Point) -&gt; Atom -&gt; f Atom
point k atom = fmap (\newPoint -&gt; atom { _point = newPoint }) (k (_point atom))</pre><p>This means that you can provide lenses for your library's types without
    depending on the <code>lens</code> library.  All you need is the <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#v:fmap">fmap</a></code> function,
    which is provided by the Haskell Prelude.</p><p><em>Question:</em> How do I combine lenses?</p><p><em>Answer:</em> You compose them, using function composition (Yes, really!)</p><p>You can think of the function composition operator as having this type:</p><pre>(.) :: Lens' a b -&gt; Lens' b c -&gt; Lens' a c</pre><p>We can compose lenses using function composition because <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> is a
    type synonym for a higher-order function:</p><pre>type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>So under the hood we are composing two higher-order functions to get back a
    new higher-order function:</p><pre>(.) :: Functor f
    =&gt; ((b -&gt; f b) -&gt; (a -&gt; f a))
    -&gt; ((c -&gt; f c) -&gt; (b -&gt; f b))
    -&gt; ((c -&gt; f c) -&gt; (a -&gt; f a))</pre><p>In our original <code>Atom</code> example, we composed the <code>point</code> and <code>x</code> lenses to
    create a new composite lens:</p><pre>point     :: Lens' Atom Point
x         :: Lens' Point Double

point . x :: Lens' Atom Double</pre><p>This composite lens lets us get or set the <code>x</code> coordinate of an <code>Atom</code>.
    We can use <code><a href="Control-Lens-Setter.html#v:over">over</a></code> and <code><a href="Control-Lens-Getter.html#v:view">view</a></code> on the composite <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> and they will behave
    exactly the way we expect:</p><pre>view (point . x) :: Atom -&gt; Double

over (point . x) :: (Double -&gt; Double) -&gt; (Atom -&gt; Atom)</pre><p><em>Question:</em> How do I consume lenses?</p><p><em>Answer:</em> Using <code><a href="Control-Lens-Getter.html#v:view">view</a></code>, <code><a href="Control-Lens-Setter.html#v:set">set</a></code> or <code><a href="Control-Lens-Setter.html#v:over">over</a></code></p><p>Here are their types:</p><pre>view :: Lens' a b -&gt; a -&gt; b

over :: Lens' a b -&gt; (b -&gt; b) -&gt; a -&gt; a

set  :: Lens' a b -&gt;       b  -&gt; a -&gt; a
set lens b = over lens (\_ -&gt; b)</pre><p><code><a href="Control-Lens-Getter.html#v:view">view</a></code> and <code><a href="Control-Lens-Setter.html#v:over">over</a></code> are the two fundamental functions on lenses.  <code><a href="Control-Lens-Setter.html#v:set">set</a></code> is
    just a special case of <code><a href="Control-Lens-Setter.html#v:over">over</a></code>.</p><p><code><a href="Control-Lens-Getter.html#v:view">view</a></code> and <code><a href="Control-Lens-Setter.html#v:over">over</a></code> are fundamental because they distribute over lens
    composition:</p><pre>view (lens1 . lens2) = (view lens2) . (view lens1)

view id = id</pre><pre>over (lens1 . lens2) = (over lens1) . (over lens2)

over id = id</pre><p><em>Question:</em> What else do I need to know?</p><p><em>Answer:</em> That's pretty much it!</p><p>For 90% of use cases, you just:</p><ul><li><p>Create lenses (using <code>makeLens</code>, <code><a href="Control-Lens-Lens.html#v:lens">lens</a></code> or plain-old <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#v:fmap">fmap</a></code>)</p><ul><li>Compose them (using (<code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Function.html#v:.">.</a></code>))</li><li>Consume them (using <code><a href="Control-Lens-Getter.html#v:view">view</a></code>, <code><a href="Control-Lens-Setter.html#v:set">set</a></code>, and <code><a href="Control-Lens-Setter.html#v:over">over</a></code>)</li></ul><p>You could actually stop reading here if you are in a hurry since this
covers the overwhelmingly common use case for the library.  On the other
hand, keep reading if you would like to learn additional tricks and
features.</p></li></ul></div><h1 id="g:4">Accessor notation</h1><div class="doc"><p>You might be used to object-oriented languages where you could retrieve a
    nested field using:</p><pre>atom.point.x</pre><p>You can do almost the exact same thing using the <code>lens</code> library, except
    that the first dot will have a <code>^</code> right before the dot:</p><pre>&gt;&gt;&gt; :load atom.hs
&gt;&gt;&gt; let atom = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
&gt;&gt;&gt; atom^.point.x
1.0</pre><p>You can better understand why this works, by adding whitespace and
    explicit parentheses:</p><pre>atom ^. (point . x)</pre><p>This trick uses (<code><a href="Control-Lens-Getter.html#v:-94-.">^.</a></code>), which is an infix operator equivalent to <code><a href="Control-Lens-Getter.html#v:view">view</a></code>:</p><pre>(^.) :: a -&gt; Lens' a b -&gt; b
x ^. l = view l x</pre><p>... and you just keep adding dots after that for each lens you compose.
    This gives the appearance of object-oriented accessors if you omit the
    whitespace around the operators.</p></div><h1 id="g:5">First-class</h1><div class="doc"><p>Lenses are &quot;first class&quot; values, meaning that you can manipulate them
    using ordinary functional programming techniques.  You can take them as
    inputs, return them as outputs, or stick them in data structures.  Anything
    goes!</p><p>For example, suppose we don't want to define separate shift functions for
    <code>Atom</code>s and <code>Molecule</code>s:</p><pre>shiftAtomX :: Atom -&gt; Atom
shiftAtomX = over (point . x) (+ 1)</pre><pre>shiftMoleculeX :: Molecule -&gt; Molecule
shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)</pre><p>We can instead unify them into a single function by parametrizing the
    shift function on the lens:</p><pre>shift lens = over lens (+ 1)</pre><p>This lets us write:</p><pre>shift (point . x) :: Atom -&gt; Atom

shift (atoms . traverse . point . x) :: Molecule -&gt; Molecule</pre><p>Even better, we can define synonyms for our composite lenses:</p><pre>atomX :: Lens' Atom Double
atomX = point . x

-- We'll learn what `Traversal` means shortly
moleculeX :: Traversal' Molecule Double
moleculeX = atoms . traverse . point . x</pre><p>Now we can write code almost identical to the original code:</p><pre>shift atomX :: Atom -&gt; Atom

shift moleculeX :: Molecule -&gt; Molecule</pre><p>... but we also get several other utilities for free:</p><pre>set atomX :: Double -&gt; Atom -&gt; Atom

set moleculeX :: Double -&gt; Molecule -&gt; Molecule

view atomX :: Atom -&gt; Double

-- We can't use `view` for `Traversal'`s.  Read on to find out why
toListOf moleculeX :: Molecule -&gt; [Double]</pre><p>That's much more reusable, but you might wonder what this <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> and
    <code><a href="Control-Lens-Fold.html#v:toListOf">toListOf</a></code> business is all about.</p></div><h1 id="g:6">Traversals</h1><div class="doc"><p><em>Question:</em> What is a traversal?</p><p><em>Answer:</em> A first class getter and setter for an arbitrary number of values</p><p>A traversal lets you get all the values it points to as a list and it also
     lets you update or set all the values it points to.  Think of a traversal
     as a record with two fields:</p><pre>data Traversal' a b = Traversal'
    { toListOf :: a -&gt; [b]
    , over     :: (b -&gt; b) -&gt; (a -&gt; a)
    }</pre><p>That's not how traversals are actually implemented, but it's a useful
     starting intuition.</p><p>We can still use <code><a href="Control-Lens-Setter.html#v:over">over</a></code> and <code><a href="Control-Lens-Setter.html#v:set">set</a></code> (a special case of <code><a href="Control-Lens-Setter.html#v:over">over</a></code>) with a
     traversal, but instead of <code><a href="Control-Lens-Getter.html#v:view">view</a></code> we use <code><a href="Control-Lens-Fold.html#v:toListOf">toListOf</a></code>.</p><p><em>Question:</em> What is the type of a traversal?</p><p><em>Answer:</em> We used one traversal in the above <code>Molecule</code> example:</p><pre>moleculeX :: Traversal' Molecule Double</pre><p>This <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> lets us get or set an arbitrary number of x coordinates,
     each of which is a <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/GHC-Exts.html#t:Double">Double</a></code>.  There could be less than one x coordinate
     (i.e. 0 coordinates) or more than one x coordinate.  Contrast this with a
     <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> which can only get or set exactly one value.</p><p>Like <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>, <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> is a type synonym for a higher-order function:</p><pre>type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)

type Lens'      a b = forall f . Functor     f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>Notice that the only difference between a <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> and a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> is the
     type class constraint.  A <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> has a <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code> constraint and
     <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> has an <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Control-Applicative.html#t:Applicative">Applicative</a></code> constraint.  This means that any <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>
     is automatically also a valid <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> (since <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code> is a superclass
     of <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Control-Applicative.html#t:Applicative">Applicative</a></code>).</p><p>Since every <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> is a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>, all of our example lenses also
     double as traversals:</p><pre>atoms   :: Traversal' Molecule [Atom]
element :: Traversal' Atom     String
point   :: Traversal' Atom     Point
x       :: Traversal' Point    Double
y       :: Traversal' Point    Double</pre><p>We actually used yet another <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>, which was <code><a href="Control-Lens-Traversal.html#v:traverse">traverse</a></code> (from
     <a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Traversable.html">Data.Traversable</a>):</p><pre>traverse :: Traversable t =&gt; Traversal' (t a) a</pre><p>This works because the <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> type synonym expands out to:</p><pre>traverse :: (Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t a -&gt; f (t a)</pre><p>... which is exactly the traditional type signature of <code><a href="Control-Lens-Traversal.html#v:traverse">traverse</a></code>:</p><p>In our <code>Molecule</code> example, we were using the special case where <code>t = []</code>:</p><pre>traverse :: Traversal' [a] a</pre><p>In Haskell, you can derive <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code>, <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Foldable.html#t:Foldable">Foldable</a></code> and
     <code><a href="Control-Lens-Traversal.html#t:Traversable">Traversable</a></code> for many data types using the <code>DeriveFoldable</code> and
     <code>DeriveTraversable</code> extensions.  This means that you can autogenerate a
     valid <code><a href="Control-Lens-Traversal.html#v:traverse">traverse</a></code> for these data types:</p><pre>{-# LANGUAGE DeriveFoldable    #-}
{-# LANGUAGE DeriveFunctor     #-}
{-# LANGUAGE DeriveTraversable #-}

import Control.Lens
import Data.Foldable

data Pair a = Pair a a deriving (Functor, Foldable, Traversable)</pre><p>We could then use <code><a href="Control-Lens-Traversal.html#v:traverse">traverse</a></code> to navigate from <code>Pair</code> to its two children:</p><pre>traverse :: Traversal' (Pair a) a

over traverse :: (a -&gt; a) -&gt; (Pair a -&gt; Pair a)

over traverse (+ 1) (Pair 3 4) = Pair 4 5</pre><p><em>Question:</em> How do I create traversals?</p><p><em>Answer:</em> There are three main ways to create primitive traversals:</p><ul><li><code><a href="Control-Lens-Traversal.html#v:traverse">traverse</a></code> is a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> that you get for any type that implements
       <code><a href="Control-Lens-Traversal.html#t:Traversable">Traversable</a></code></li><li>Every <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> will also type-check as a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code></li><li>You can use Template Haskell to generate <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s using <code><a href="Control-Lens-Internal-PrismTH.html#v:makePrisms">makePrisms</a></code>
       since every <code><a href="Control-Lens-Type.html#t:Prism-39-">Prism'</a></code> is also a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> (not covered in this
       tutorial)</li></ul><p><em>Question:</em> How do I combine traversals?</p><p><em>Answer:</em> You compose them, using function composition</p><p>You can think of the function composition operator as having this type:</p><pre>(.) :: Traversal' a b -&gt; Traversal' b c -&gt; Traversal' a c</pre><p>We can compose traversals using function composition because a
     <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> is a type synonym for a higher-order function:</p><pre>type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>So under the hood we are composing two functions to get back a new
     function:</p><pre>(.) :: Applicative f
    =&gt; ((b -&gt; f b) -&gt; (a -&gt; f a))
    -&gt; ((c -&gt; f c) -&gt; (b -&gt; f b))
    -&gt; ((c -&gt; f c) -&gt; (a -&gt; f a))</pre><p>In our original <code>Molecule</code> example, we composed four <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s
     together to create a new <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>:</p><pre>-- Remember that `atoms`, `point`, and `x` are also `Traversal'`s
atoms                        :: Traversal' Molecule [Atom]
traverse                     :: Traversal' [Atom]   Atom
point                        :: Traversal' Atom     Point
x                            :: Traversal' Point    Double

-- Now compose them
atoms                        :: Traversal' Molecule [Atom]
atoms . traverse             :: Traversal' Molecule Atom
atoms . traverse . point     :: Traversal' Molecule Point
atoms . traverse . point . x :: Traversal' Molecule Double</pre><p>This composite traversal lets us get or set the <code>x</code> coordinates of a
     <code>Molecule</code>.</p><pre>over (atoms . traverse . point . x)
    :: (Double -&gt; Double) -&gt; (Molecule -&gt; Molecule)

toListOf (atoms . traverse . point . x) :: Molecule -&gt; [Double]</pre><p><em>Question:</em> How do I consume traversals?</p><p><em>Answer:</em> Using <code><a href="Control-Lens-Fold.html#v:toListOf">toListOf</a></code>, <code><a href="Control-Lens-Setter.html#v:set">set</a></code> or <code><a href="Control-Lens-Setter.html#v:over">over</a></code></p><p>Here are their types:</p><pre>toListOf :: Lens' a b -&gt; a -&gt; [b]

over :: Traversal' a b -&gt; (b -&gt; b) -&gt; a -&gt; a

set  :: Traversal' a b -&gt;       b  -&gt; a -&gt; a
set traversal b = over traversal (\_ -&gt; b)</pre><p><code><a href="Control-Lens-Fold.html#v:toListOf">toListOf</a></code> distributes over traversal composition:</p><pre>toListOf (traversal1 . traversal2) = (toListOf traversal1) &gt;=&gt; (toListOf traversal2)

toListOf id = return</pre><p>You can also use (<code><a href="Control-Lens-Fold.html#v:-94-..">^..</a></code>), which is an infix operator equivalent to
 <code><a href="Control-Lens-Fold.html#v:toListOf">toListOf</a></code>:</p><pre>&gt;&gt;&gt; Pair 3 4 ^.. traverse
[3,4]</pre></div><h1 id="g:7">Types</h1><div class="doc"><p>You might wonder why you can use <code><a href="Control-Lens-Setter.html#v:over">over</a></code> on both a <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> and a
    <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> but you can only use <code><a href="Control-Lens-Getter.html#v:view">view</a></code> on a <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>.  We can see why by
    studying the (simplified) type and implementation of <code><a href="Control-Lens-Setter.html#v:over">over</a></code>:</p><pre>over :: ((b -&gt; Identity b) -&gt; (a -&gt; Identity b)) -&gt; (b -&gt; b) -&gt; a -&gt; a
over setter f x = runIdentity (setter (\y -&gt; Identity (f y)) x)</pre><p>To follow the implementation, just step slowly through the types:</p><pre>setter :: (b -&gt; Identity b) -&gt; (a -&gt; Identity b)
f      :: b -&gt; b
x      :: a</pre><pre>                     \y -&gt; Identity (f y)     :: b -&gt; Identity b
             setter (\y -&gt; Identity (f y))    :: a -&gt; Identity a
             setter (\y -&gt; Identity (f y)) x  ::      Identity a
runIdentity (setter (\y -&gt; Identity (f y)) x) ::               a</pre><p>We can replace <code>setter</code> with <code>point</code> and replace <code>x</code> with <code>atom</code> to see
     that this generates the correct code for updating an atom's point:</p><pre>  over point f atom

-- Definition of `over`
= runIdentity (point (\y -&gt; Identity (f y)) atom)

-- Definition of `point`
= runIdentity (fmap (\newPoint -&gt; atom { _point = newPoint }) (Identity (f (_point atom)))

-- fmap g (Identity y) = Identity (g y)
= runIdentity (Identity (atom { _point = f (_point atom) }))

-- runIdentity (Identity z) = z
= atom { _point = f (_point atom) }</pre><p>... which is exactly what we would have written by hand without lenses.</p><p>The reason <code><a href="Control-Lens-Setter.html#v:over">over</a></code> works for both <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>es and <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s is because
    <code><a href="Control-Lens-Setter.html#t:Identity">Identity</a></code> implements both <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code> and <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Control-Applicative.html#t:Applicative">Applicative</a></code>:</p><pre>instance Functor     Identity where ...
instance Applicative Identity where ...</pre><p>So both the <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> type and <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> type synonyms:</p><pre>type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)

type Lens'      a b = forall f . Functor     f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>... can be specialized to use <code><a href="Control-Lens-Setter.html#t:Identity">Identity</a></code> in place of <code>f</code>:</p><pre>(b -&gt; Identity b) -&gt; (a -&gt; Identity a)</pre><p>... making them valid arguments to <code><a href="Control-Lens-Setter.html#v:over">over</a></code>.</p><p>Now let's study the (simplified) type and implementation of <code><a href="Control-Lens-Getter.html#v:view">view</a></code>:</p><pre>view :: ((b -&gt; Const b b) -&gt; (a -&gt; Const b a)) -&gt; a -&gt; b
view getter x = getConst (getter Const x)</pre><p>Again, we can walk slowly through the types:</p><pre>getter :: (b -&gt; Const b b) -&gt; (a -&gt; Const b a)
x      :: a</pre><pre>getter Const              :: a -&gt; Const b a
getter Const x            ::      Const b a
getConst (getter Const x) ::            b</pre><p>Let's see how this plays out for the <code>point</code> lens:</p><pre>  view point atom

-- Definition of `view`
= getConst (point Const atom)

-- Definition of `point`
= getConst (fmap (\newPoint -&gt; atom { _point = newPoint }) (Const (_point atom)))

-- fmap g (Const y) = Const y
= getConst (Const (_point atom))

-- getConst (Const z) = z
= _point atom</pre><p>... which is exactly what we would have written by hand without lenses.</p><p><code><a href="Control-Lens-Getter.html#v:view">view</a></code> accepts <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code>es because <code><a href="Control-Lens-Getter.html#t:Const">Const</a></code> implements <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Functor.html#t:Functor">Functor</a></code>:</p><pre>instance Functor (Const b)</pre><p>... so the <code><a href="Control-Lens-Type.html#t:Lens-39-">Lens'</a></code> type synonym:</p><pre>type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</pre><p>... can be specialized to use <code>(<code><a href="Control-Lens-Getter.html#t:Const">Const</a></code> b)</code> in place of <code>f</code>:</p><pre>(b -&gt; Const b b) -&gt; (a -&gt; Const b b)</pre><p>... making it a valid argument to <code><a href="Control-Lens-Getter.html#v:view">view</a></code>.</p><p>Interestingly, <code><a href="Control-Lens-Getter.html#t:Const">Const</a></code> implements also <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Control-Applicative.html#t:Applicative">Applicative</a></code>, but with a
    constraint:</p><pre>instance Monoid b =&gt; Applicative (Const b)</pre><p>This implies that we *can* use <code><a href="Control-Lens-Getter.html#v:view">view</a></code> on a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>, but only if the
    value that we extract is a <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#t:Monoid">Monoid</a></code>.  Let's try this out:</p><pre>&gt;&gt;&gt; :load atom.hs
&gt;&gt;&gt; let atom1 = Atom { _element = &quot;C&quot;, _point = Point { _x = 1.0, _y = 2.0 } }
&gt;&gt;&gt; let atom2 = Atom { _element = &quot;O&quot;, _point = Point { _x = 3.0, _y = 4.0 } }
&gt;&gt;&gt; let molecule = Molecule { _atoms = [atom1, atom2] }
&gt;&gt;&gt; view (atoms . traverse . element) molecule
&quot;CO&quot;</pre><p>This works because our traversal's result is a <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-String.html#t:String">String</a></code>:</p><pre>atoms . traverse . element :: Traversal' Molecule String</pre><p>... and <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-String.html#t:String">String</a></code> implements the <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#t:Monoid">Monoid</a></code> interface.  When you
    try to extract multiple strings using <code><a href="Control-Lens-Getter.html#v:view">view</a></code> they get flattened together
    into a single <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-String.html#t:String">String</a></code> using <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#v:mappend">mappend</a></code>.</p><p>If you try to extract the element from an empty molecule:</p><pre>&gt;&gt;&gt; view (atoms . traverse . element) (Molecule { _atoms = [] })
&quot;&quot;</pre><p>You get the empty string (i.e. <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#v:mempty">mempty</a></code>).</p><p>This is why the result of a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> needs to be a <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#t:Monoid">Monoid</a></code>
    when using <code><a href="Control-Lens-Getter.html#v:view">view</a></code>.  If the <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> points to more than one value you
    need some way to combine them into a single value (using
    <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#v:mappend">mappend</a></code>) and if the <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> points to less than one
    value you need a default value to return (using <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#v:mempty">mempty</a></code>).</p><p>If you try to <code><a href="Control-Lens-Getter.html#v:view">view</a></code> a <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> that doesn't point to a
    <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#t:Monoid">Monoid</a></code>, you will get the following type error:</p><pre>&gt;&gt;&gt; view (atoms . traverse . point . x) molecule
    No instance for (Data.Monoid.Monoid Double)
      arising from a use of `traverse'
    Possible fix:
      add an instance declaration for (Data.Monoid.Monoid Double)
    In the first argument of `(.)', namely `traverse'
    In the second argument of `(.)', namely `traverse . point . x'
    In the first argument of `view', namely
      `(atoms . traverse . point . x)'</pre><p>The compiler complains that <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/GHC-Exts.html#t:Double">Double</a></code> does not implement the
    <code><a href="file:///home/ghc-7.10.1/share/doc/ghc/html/libraries/base-4.8.0.0/Data-Monoid.html#t:Monoid">Monoid</a></code> type class, so there is no sensible way to merge all
    the x coordinates that our <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code> points to.  For these cases you
    should use <code><a href="Control-Lens-Fold.html#v:toListOf">toListOf</a></code> instead.</p></div><h1 id="g:8">Drawbacks</h1><div class="doc"><p>Lenses come with trade-offs, so you should use them wisely.</p><p>For example, lenses do not produce the best error messages.  Unless you
    understand how <code><a href="Control-Lens-Type.html#t:Traversal-39-">Traversal'</a></code>s work you will probably not understand this
    error message:</p><pre>&gt;&gt;&gt; view (atoms . traverse . point . x) molecule
    No instance for (Data.Monoid.Monoid Double)
      arising from a use of `traverse'
    Possible fix:
      add an instance declaration for (Data.Monoid.Monoid Double)
    In the first argument of `(.)', namely `traverse'
    In the second argument of `(.)', namely `traverse . point . x'
    In the first argument of `view', namely
      `(atoms . traverse . point . x)'</pre><p>Also, lenses increase the learning curve for new Haskell programmers, so
    you should consider avoiding them in tutorial code targeting novice
    Haskell programmers.</p><p>Lenses also add a level of boilerplate to all data types to auto-generate
    lenses and increase compile times.  So for small projects the overhead of
    adding lenses may dwarf the benefits.</p><p><code>lens</code> is also a library with a large dependency tree.  If you need a
    more light-weight alternative you can use the <code>lens-simple</code> library which
    provides a restricted subset of this library with a much smaller dependency
    tree.  In contrast, this <code>lens</code> library focuses on being &quot;batteries
    included&quot; and significantly more general.</p><p>The ideal use case for the <code>lens</code> library is a large project with rich and
    deeply nested types.  In these large projects the benefits of using lenses
    outweigh the costs.</p></div><h1 id="g:9">Conclusion</h1><div class="doc"><p>This tutorial covers an extremely small subset of this library.  If you
    would like to learn more, you can begin by skimming the example code in the
    following modules:</p><ul><li><p><a href="Control-Lens-Getter.html">Control.Lens.Getter</a></p><ul><li><a href="Control-Lens-Setter.html">Control.Lens.Setter</a></li><li><a href="Control-Lens-Traversal.html">Control.Lens.Traversal</a></li><li><a href="Control-Lens-Tuple.html">Control.Lens.Tuple</a></li><li><a href="Control-Lens-Lens.html">Control.Lens.Lens</a></li><li><a href="Control-Lens-Review.html">Control.Lens.Review</a></li><li><a href="Control-Lens-Prism.html">Control.Lens.Prism</a></li><li><a href="Control-Lens-Iso.html">Control.Lens.Iso</a></li></ul><p>The documentation for these modules includes several examples to get you
started and help you build an intuition for more advanced tricks.</p><p>You can also study several long-form examples here:</p><p><a href="https://github.com/ekmett/lens/tree/master/examples">https://github.com/ekmett/lens/tree/master/examples</a></p><p>If you would like a broader survey of lens features, then you can check
out these tutorials:</p></li><li><p><a href="https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial">A little lens starter tutorial</a> - Introduces
Prisms, Isos and JSON functionality</p><ul><li><a href="http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html">Program imperatively using Haskell lenses</a> - Illustrates lens support for stateful code</li></ul></li></ul></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.16.0</p></div></body></html>