<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Control/Lens.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE CPP #-}</span>
<a name="line-2"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-3"></a><span class='hs-comment'>-- |</span>
<a name="line-4"></a><span class='hs-comment'>-- Module      :  Control.Lens</span>
<a name="line-5"></a><span class='hs-comment'>-- Copyright   :  (C) 2012-15 Edward Kmett</span>
<a name="line-6"></a><span class='hs-comment'>-- License     :  BSD-style (see the file LICENSE)</span>
<a name="line-7"></a><span class='hs-comment'>-- Maintainer  :  Edward Kmett &lt;ekmett@gmail.com&gt;</span>
<a name="line-8"></a><span class='hs-comment'>-- Stability   :  experimental</span>
<a name="line-9"></a><span class='hs-comment'>-- Portability :  non-portable</span>
<a name="line-10"></a><span class='hs-comment'>--</span>
<a name="line-11"></a><span class='hs-comment'>-- Usage:</span>
<a name="line-12"></a><span class='hs-comment'>--</span>
<a name="line-13"></a><span class='hs-comment'>-- You can derive lenses automatically for many data types:</span>
<a name="line-14"></a><span class='hs-comment'>--</span>
<a name="line-15"></a><span class='hs-comment'>-- @</span>
<a name="line-16"></a><span class='hs-comment'>-- import Control.Lens</span>
<a name="line-17"></a><span class='hs-comment'>-- </span>
<a name="line-18"></a><span class='hs-comment'>-- data FooBar a</span>
<a name="line-19"></a><span class='hs-comment'>--   = Foo { _x :: ['Int'], _y :: a }</span>
<a name="line-20"></a><span class='hs-comment'>--   | Bar { _x :: ['Int'] }</span>
<a name="line-21"></a><span class='hs-comment'>-- 'makeLenses' ''FooBar</span>
<a name="line-22"></a><span class='hs-comment'>-- @</span>
<a name="line-23"></a><span class='hs-comment'>--</span>
<a name="line-24"></a><span class='hs-comment'>-- This defines the following lenses:</span>
<a name="line-25"></a><span class='hs-comment'>--</span>
<a name="line-26"></a><span class='hs-comment'>-- @</span>
<a name="line-27"></a><span class='hs-comment'>-- x :: 'Lens'' (FooBar a) ['Int']</span>
<a name="line-28"></a><span class='hs-comment'>-- y :: 'Traversal' (FooBar a) (FooBar b) a b</span>
<a name="line-29"></a><span class='hs-comment'>-- @</span>
<a name="line-30"></a><span class='hs-comment'>--</span>
<a name="line-31"></a><span class='hs-comment'>-- You can then access the value of @_x@ with ('^.'), the value of @_y@ â€“</span>
<a name="line-32"></a><span class='hs-comment'>-- with ('^?') or ('^?!') (since it can fail), set the values with ('.~'),</span>
<a name="line-33"></a><span class='hs-comment'>-- modify them with ('%~'), and use almost any other combinator that is</span>
<a name="line-34"></a><span class='hs-comment'>-- re-exported here on those fields.</span>
<a name="line-35"></a><span class='hs-comment'>--</span>
<a name="line-36"></a><span class='hs-comment'>-- The combinators here have unusually specific type signatures, so for</span>
<a name="line-37"></a><span class='hs-comment'>-- particularly tricky ones, the simpler type signatures you might want to</span>
<a name="line-38"></a><span class='hs-comment'>-- pretend the combinators have are specified as well.</span>
<a name="line-39"></a><span class='hs-comment'>--</span>
<a name="line-40"></a><span class='hs-comment'>-- More information on how to use lenses is available on the lens wiki:</span>
<a name="line-41"></a><span class='hs-comment'>--</span>
<a name="line-42"></a><span class='hs-comment'>-- &lt;<a href="http://github.com/ekmett/lens/wiki">http://github.com/ekmett/lens/wiki</a>&gt;</span>
<a name="line-43"></a><span class='hs-comment'>--</span>
<a name="line-44"></a><span class='hs-comment'>-- &lt;&lt;Hierarchy.png&gt;&gt;</span>
<a name="line-45"></a><span class='hs-comment'>----------------------------------------------------------------------------</span>
<a name="line-46"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span>
<a name="line-47"></a>  <span class='hs-layout'>(</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>At</span>
<a name="line-48"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Cons</span>
<a name="line-49"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Each</span>
<a name="line-50"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Empty</span>
<a name="line-51"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Equality</span>
<a name="line-52"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Fold</span>
<a name="line-53"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Getter</span>
<a name="line-54"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Indexed</span>
<a name="line-55"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Iso</span>
<a name="line-56"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span>
<a name="line-57"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Level</span>
<a name="line-58"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Plated</span>
<a name="line-59"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Prism</span>
<a name="line-60"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Reified</span>
<a name="line-61"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Review</span>
<a name="line-62"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Setter</span>
<a name="line-63"></a><span class='hs-cpp'>#ifndef DISABLE_TEMPLATE_HASKELL</span>
<a name="line-64"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>TH</span>
<a name="line-65"></a><span class='hs-cpp'>#endif</span>
<a name="line-66"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Traversal</span>
<a name="line-67"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Tuple</span>
<a name="line-68"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Type</span>
<a name="line-69"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Wrapped</span>
<a name="line-70"></a>  <span class='hs-layout'>,</span> <span class='hs-keyword'>module</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Zoom</span>
<a name="line-71"></a>
<a name="line-72"></a>  <span class='hs-comment'>-- * Tutorial</span>
<a name="line-73"></a>  <span class='hs-comment'>-- $tutorial</span>
<a name="line-74"></a>
<a name="line-75"></a>  <span class='hs-comment'>-- * Motivation</span>
<a name="line-76"></a>  <span class='hs-comment'>-- $motivation</span>
<a name="line-77"></a>
<a name="line-78"></a>  <span class='hs-comment'>-- * Lenses</span>
<a name="line-79"></a>  <span class='hs-comment'>-- $lenses</span>
<a name="line-80"></a>
<a name="line-81"></a>  <span class='hs-comment'>-- * Accessor notation</span>
<a name="line-82"></a>  <span class='hs-comment'>-- $accessors</span>
<a name="line-83"></a>
<a name="line-84"></a>  <span class='hs-comment'>-- * First-class</span>
<a name="line-85"></a>  <span class='hs-comment'>-- $firstclass</span>
<a name="line-86"></a>
<a name="line-87"></a>  <span class='hs-comment'>-- * Traversals</span>
<a name="line-88"></a>  <span class='hs-comment'>-- $traversals</span>
<a name="line-89"></a>
<a name="line-90"></a>  <span class='hs-comment'>-- * Types</span>
<a name="line-91"></a>  <span class='hs-comment'>-- $types</span>
<a name="line-92"></a>
<a name="line-93"></a>  <span class='hs-comment'>-- * Drawbacks</span>
<a name="line-94"></a>  <span class='hs-comment'>-- $drawbacks</span>
<a name="line-95"></a>
<a name="line-96"></a>  <span class='hs-comment'>-- * Conclusion</span>
<a name="line-97"></a>  <span class='hs-comment'>-- $conclusion</span>
<a name="line-98"></a>  <span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-99"></a>
<a name="line-100"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>At</span>
<a name="line-101"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Cons</span>
<a name="line-102"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Each</span>
<a name="line-103"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Empty</span>
<a name="line-104"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Equality</span>
<a name="line-105"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Fold</span>
<a name="line-106"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Getter</span>
<a name="line-107"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Indexed</span>
<a name="line-108"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Iso</span>
<a name="line-109"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span>
<a name="line-110"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Level</span>
<a name="line-111"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Plated</span>
<a name="line-112"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Prism</span>
<a name="line-113"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Reified</span>
<a name="line-114"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Review</span>
<a name="line-115"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Setter</span>
<a name="line-116"></a><span class='hs-cpp'>#ifndef DISABLE_TEMPLATE_HASKELL</span>
<a name="line-117"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>TH</span>
<a name="line-118"></a><span class='hs-cpp'>#endif</span>
<a name="line-119"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Traversal</span>
<a name="line-120"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Tuple</span>
<a name="line-121"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Type</span>
<a name="line-122"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Wrapped</span>
<a name="line-123"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Control</span><span class='hs-varop'>.</span><span class='hs-conid'>Lens</span><span class='hs-varop'>.</span><span class='hs-conid'>Zoom</span>
<a name="line-124"></a>
<a name="line-125"></a><span class='hs-cpp'>#ifdef HLINT</span>
<a name="line-126"></a><span class='hs-comment'>{-# ANN module "HLint: ignore Use import/export shortcut" #-}</span>
<a name="line-127"></a><span class='hs-cpp'>#endif</span>
<a name="line-128"></a>
<a name="line-129"></a><span class='hs-comment'>{- $tutorial
<a name="line-130"></a>    This @lens@ tutorial targets Haskell beginners and assumes only basic
<a name="line-131"></a>    familiarity with Haskell.  By the end of this tutorial you should:
<a name="line-132"></a>
<a name="line-133"></a>    * understand what problems the @lens@ library solves,
<a name="line-134"></a>
<a name="line-135"></a>    * know when it is appropriate to use the @lens@ library,
<a name="line-136"></a>
<a name="line-137"></a>    * be proficient in the most common @lens@ idioms,
<a name="line-138"></a>
<a name="line-139"></a>    * understand the drawbacks of using lenses, and:
<a name="line-140"></a>
<a name="line-141"></a>    * know where to look if you wish to learn more advanced tricks.
<a name="line-142"></a>-}</span>
<a name="line-143"></a>
<a name="line-144"></a><span class='hs-comment'>-- $motivation</span>
<a name="line-145"></a><span class='hs-comment'>--</span>
<a name="line-146"></a><span class='hs-comment'>--     The simplest problem that the @lens@ library solves is updating deeply</span>
<a name="line-147"></a><span class='hs-comment'>--     nested records.  Suppose you had the following nested Haskell data types:</span>
<a name="line-148"></a><span class='hs-comment'>-- </span>
<a name="line-149"></a><span class='hs-comment'>-- &gt; data Atom = Atom { _element :: String, _point :: Point }</span>
<a name="line-150"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-151"></a><span class='hs-comment'>-- &gt; data Point = Point { _x :: Double, _y :: Double }</span>
<a name="line-152"></a><span class='hs-comment'>-- </span>
<a name="line-153"></a><span class='hs-comment'>--     If you wanted to increase the @x@ coordinate of an `Atom` by one unit, you</span>
<a name="line-154"></a><span class='hs-comment'>--     would have to write something like this in Haskell:</span>
<a name="line-155"></a><span class='hs-comment'>-- </span>
<a name="line-156"></a><span class='hs-comment'>-- &gt; shiftAtomX :: Atom -&gt; Atom</span>
<a name="line-157"></a><span class='hs-comment'>-- &gt; shiftAtomX (Atom e (Point x y)) = Atom e (Point (x + 1) y)</span>
<a name="line-158"></a><span class='hs-comment'>-- </span>
<a name="line-159"></a><span class='hs-comment'>--     This unpacking and repacking of data types grows increasingly difficult the</span>
<a name="line-160"></a><span class='hs-comment'>--     more fields you add to each data type or the more deeply nested your data</span>
<a name="line-161"></a><span class='hs-comment'>--     structures become.</span>
<a name="line-162"></a><span class='hs-comment'>-- </span>
<a name="line-163"></a><span class='hs-comment'>--     The @lens@ library solves this problem by letting you instead write:</span>
<a name="line-164"></a><span class='hs-comment'>-- </span>
<a name="line-165"></a><span class='hs-comment'>-- &gt; -- atom.hs</span>
<a name="line-166"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-167"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE TemplateHaskell #-}</span>
<a name="line-168"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-169"></a><span class='hs-comment'>-- &gt; import Control.Lens hiding (element)</span>
<a name="line-170"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-171"></a><span class='hs-comment'>-- &gt; data Atom = Atom { _element :: String, _point :: Point } deriving (Show)</span>
<a name="line-172"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-173"></a><span class='hs-comment'>-- &gt; data Point = Point { _x :: Double, _y :: Double } deriving (Show)</span>
<a name="line-174"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-175"></a><span class='hs-comment'>-- &gt; makeLenses ''Atom</span>
<a name="line-176"></a><span class='hs-comment'>-- &gt; makeLenses ''Point</span>
<a name="line-177"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-178"></a><span class='hs-comment'>-- &gt; shiftAtomX :: Atom -&gt; Atom</span>
<a name="line-179"></a><span class='hs-comment'>-- &gt; shiftAtomX = over (point . x) (+ 1)</span>
<a name="line-180"></a><span class='hs-comment'>-- </span>
<a name="line-181"></a><span class='hs-comment'>--     Let's convince ourselves that this works:</span>
<a name="line-182"></a><span class='hs-comment'>-- </span>
<a name="line-183"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; :load atom.hs</span>
<a name="line-184"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; let atom = Atom { _element = "C", _point = Point { _x = 1.0, _y = 2.0 } }</span>
<a name="line-185"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; shiftAtomX atom</span>
<a name="line-186"></a><span class='hs-comment'>-- &gt; Atom {_element = "C", _point = Point {_x = 2.0, _y = 2.0}}</span>
<a name="line-187"></a><span class='hs-comment'>-- </span>
<a name="line-188"></a><span class='hs-comment'>--     The above solution does not change no matter how many fields we add to</span>
<a name="line-189"></a><span class='hs-comment'>--     @Atom@ or @Point@.</span>
<a name="line-190"></a><span class='hs-comment'>-- </span>
<a name="line-191"></a><span class='hs-comment'>--     Now suppose that we added yet another data structure:</span>
<a name="line-192"></a><span class='hs-comment'>-- </span>
<a name="line-193"></a><span class='hs-comment'>-- &gt; data Molecule = Molecule { _atoms :: [Atom] } deriving (Show)</span>
<a name="line-194"></a><span class='hs-comment'>-- </span>
<a name="line-195"></a><span class='hs-comment'>--     We could shift an entire @Molecule@ by writing:</span>
<a name="line-196"></a><span class='hs-comment'>-- </span>
<a name="line-197"></a><span class='hs-comment'>-- &gt; makeLenses ''Molecule</span>
<a name="line-198"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-199"></a><span class='hs-comment'>-- &gt; shiftMoleculeX :: Molecule -&gt; Molecule</span>
<a name="line-200"></a><span class='hs-comment'>-- &gt; shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)</span>
<a name="line-201"></a><span class='hs-comment'>-- </span>
<a name="line-202"></a><span class='hs-comment'>--     Again, this works the way we expect:</span>
<a name="line-203"></a><span class='hs-comment'>-- </span>
<a name="line-204"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; :load atom.hs</span>
<a name="line-205"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; let atom1 = Atom { _element = "C", _point = Point { _x = 1.0, _y = 2.0 } }</span>
<a name="line-206"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; let atom2 = Atom { _element = "O", _point = Point { _x = 3.0, _y = 4.0 } }</span>
<a name="line-207"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; let molecule = Molecule { _atoms = [atom1, atom2] }</span>
<a name="line-208"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; shiftMoleculeX molecule  -- Output formatted for clarity</span>
<a name="line-209"></a><span class='hs-comment'>-- &gt; Molecule</span>
<a name="line-210"></a><span class='hs-comment'>-- &gt;     { _atoms =</span>
<a name="line-211"></a><span class='hs-comment'>-- &gt;         [ Atom { _element = "C", _point = Point { _x = 2.0, _y = 2.0 } }</span>
<a name="line-212"></a><span class='hs-comment'>-- &gt;         , Atom { _element = ")", _point = Point { _x = 4.0, _y = 4.0 } }</span>
<a name="line-213"></a><span class='hs-comment'>-- &gt;         ]</span>
<a name="line-214"></a><span class='hs-comment'>-- &gt;     }</span>
<a name="line-215"></a><span class='hs-comment'>-- </span>
<a name="line-216"></a><span class='hs-comment'>--     Many people stumble across lenses while trying to solve this common problem</span>
<a name="line-217"></a><span class='hs-comment'>--     of working with data structures with a large number of fields or deeply</span>
<a name="line-218"></a><span class='hs-comment'>--     nested values.  These sorts of situations arise commonly in:</span>
<a name="line-219"></a><span class='hs-comment'>-- </span>
<a name="line-220"></a><span class='hs-comment'>--     * games with complex and deeply nested state</span>
<a name="line-221"></a><span class='hs-comment'>-- </span>
<a name="line-222"></a><span class='hs-comment'>--     * scientific data formats</span>
<a name="line-223"></a><span class='hs-comment'>-- </span>
<a name="line-224"></a><span class='hs-comment'>--     * sensor or instrument output</span>
<a name="line-225"></a><span class='hs-comment'>-- </span>
<a name="line-226"></a><span class='hs-comment'>--     * web APIs</span>
<a name="line-227"></a><span class='hs-comment'>-- </span>
<a name="line-228"></a><span class='hs-comment'>--     * XML and JSON</span>
<a name="line-229"></a><span class='hs-comment'>-- </span>
<a name="line-230"></a><span class='hs-comment'>--     * enterprise code where data structures can have tens, hundreds, or even</span>
<a name="line-231"></a><span class='hs-comment'>--       thousands of fields (true story!)</span>
<a name="line-232"></a>
<a name="line-233"></a><span class='hs-comment'>{- $lenses
<a name="line-234"></a>    You might have some basic questions like:
<a name="line-235"></a>
<a name="line-236"></a>    /Question:/ What is a lens?
<a name="line-237"></a>
<a name="line-238"></a>    /Answer:/ A lens is a first class getter and setter
<a name="line-239"></a>
<a name="line-240"></a>    We already saw how to use lenses to update values using `over`, but we can
<a name="line-241"></a>    also use lenses to retrieve values using `view`:
<a name="line-242"></a>
<a name="line-243"></a>&gt; &gt;&gt;&gt; :load atom.hs
<a name="line-244"></a>&gt; &gt;&gt;&gt; let atom = Atom { _element = "C", _point = Point { _x = 1.0, _y = 2.0 } }
<a name="line-245"></a>&gt; &gt;&gt;&gt; view (point . x) atom
<a name="line-246"></a>&gt; 1
<a name="line-247"></a>
<a name="line-248"></a>    In other words, lenses package both \"get\" and \"set\" functionality into
<a name="line-249"></a>    a single value (the lens).  You could pretend that a lens is a record
<a name="line-250"></a>    with two fields:
<a name="line-251"></a>
<a name="line-252"></a>&gt; data Lens a b = Lens
<a name="line-253"></a>&gt;     { view :: a -&gt; b
<a name="line-254"></a>&gt;     , over :: (b -&gt; b) -&gt; (a -&gt; a)
<a name="line-255"></a>&gt;     }
<a name="line-256"></a>
<a name="line-257"></a>    That's not how lenses are actually implemented, but it's a useful
<a name="line-258"></a>    starting intuition.
<a name="line-259"></a>
<a name="line-260"></a>    /Question:/ What is the type of a lens?
<a name="line-261"></a>
<a name="line-262"></a>    /Answer:/ We used two lenses in the above @Atom@ example, with these types:
<a name="line-263"></a>
<a name="line-264"></a>&gt; point :: Lens' Atom  Point
<a name="line-265"></a>&gt; x     :: Lens' Point Double
<a name="line-266"></a>
<a name="line-267"></a>    The @point@ lens contains all the information we need to get or set the
<a name="line-268"></a>    @_point@ field of the @Atom@ type (which is a `Point`).  Similarly, the @x@
<a name="line-269"></a>    lens contains all the information we need to get or set the @_x@ field of
<a name="line-270"></a>    the @Point@ data type (which is a `Double`).
<a name="line-271"></a>
<a name="line-272"></a>    The convention for the `Lens'` type parameters is:
<a name="line-273"></a>
<a name="line-274"></a>&gt; --    +-- Bigger type
<a name="line-275"></a>&gt; --    |
<a name="line-276"></a>&gt; --    v
<a name="line-277"></a>&gt; Lens' bigger smaller
<a name="line-278"></a>&gt; --           ^
<a name="line-279"></a>&gt; --           |
<a name="line-280"></a>&gt; --           +--  Smaller type within the bigger type
<a name="line-281"></a>
<a name="line-282"></a>    The actual definition of `Lens'` is:
<a name="line-283"></a>
<a name="line-284"></a>&gt; type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
<a name="line-285"></a>
<a name="line-286"></a>    You might wonder how you can fit both getter and setter functionality in
<a name="line-287"></a>    a single value like this.  The trick is that we get to pick what `Functor`
<a name="line-288"></a>    we specialize @f@ to and depending on which `Functor` we pick we get
<a name="line-289"></a>    different features.
<a name="line-290"></a>
<a name="line-291"></a>    For example, if you pick @(f = `Identity`)@:
<a name="line-292"></a>
<a name="line-293"></a>&gt; type ASetter' a b   = (b -&gt; Identity b) -&gt; (a -&gt; Identity a)
<a name="line-294"></a>&gt;
<a name="line-295"></a>&gt; -- ... equivalent to: (b -&gt;          b) -&gt; (a -&gt;          a)
<a name="line-296"></a>
<a name="line-297"></a>    ... you can build an `over`-like function.
<a name="line-298"></a>
<a name="line-299"></a>    Similarly, if you pick @(f = `Const` b)@:
<a name="line-300"></a>
<a name="line-301"></a>&gt; type Getting b a b  = (b -&gt; Const b b) -&gt; (a -&gt; Const b b)
<a name="line-302"></a>&gt;
<a name="line-303"></a>&gt; -- ... equivalent to: (b -&gt;       b  ) -&gt; (a -&gt;       b  )
<a name="line-304"></a>&gt;
<a name="line-305"></a>&gt; -- ... equivalent to:                     (a -&gt;       b  )
<a name="line-306"></a>
<a name="line-307"></a>    ... you can build a `view`-like function.
<a name="line-308"></a>
<a name="line-309"></a>    Those are not the only two `Functor`s we can pick.  In fact, we can do a
<a name="line-310"></a>    lot more with lenses than just get and set values, but those are the two
<a name="line-311"></a>    most commonly used features.
<a name="line-312"></a>
<a name="line-313"></a>    /Question:/ How do I create lenses?
<a name="line-314"></a>
<a name="line-315"></a>    /Answer:/ You can either auto-generate them using Template Haskell or
<a name="line-316"></a>    create them by hand
<a name="line-317"></a>
<a name="line-318"></a>    In our @Atom@ example, we auto-generated the lenses using Template Haskell,
<a name="line-319"></a>    like this:
<a name="line-320"></a>
<a name="line-321"></a>&gt; makeLenses ''Atom
<a name="line-322"></a>&gt; makeLenses ''Point
<a name="line-323"></a>
<a name="line-324"></a>    This created four lenses of the following types:
<a name="line-325"></a>
<a name="line-326"></a>&gt; element :: Lens' Atom String
<a name="line-327"></a>&gt; point   :: Lens' Atom Point
<a name="line-328"></a>&gt; x       :: Lens' Point Double
<a name="line-329"></a>&gt; y       :: Lens' Point Double
<a name="line-330"></a>
<a name="line-331"></a>    `makeLenses` creates one lens per field prefixed with an underscore.  The
<a name="line-332"></a>    lens has the same name as the field without the underscore.
<a name="line-333"></a>
<a name="line-334"></a>    However, sometimes Template Haskell is not an option, so we can also use
<a name="line-335"></a>    the `lens` utility function to build lenses.  This utility has type:
<a name="line-336"></a>
<a name="line-337"></a>&gt; lens :: (a -&gt; b) -&gt; (b -&gt; a -&gt; a) -&gt; Lens' a b
<a name="line-338"></a>
<a name="line-339"></a>    The first argument is a \"getter\" (a way to extract a @\'b\'@ from an
<a name="line-340"></a>    @\'a\'@).  The second argument is a \"setter\" (given a @b@, update an
<a name="line-341"></a>    @a@).  The result is a `Lens'` built from the getter and setter.  You would
<a name="line-342"></a>    use `lens` like this:
<a name="line-343"></a>
<a name="line-344"></a>&gt; point :: Lens' Atom Point
<a name="line-345"></a>&gt; point = lens _point (\newPoint atom -&gt; atom { _point = newPoint })
<a name="line-346"></a>
<a name="line-347"></a>    You can even define lenses without incurring a dependency on the @lens@
<a name="line-348"></a>    library.  Remember that lenses are just higher-order functions over
<a name="line-349"></a>    `Functor`s, so we could instead write:
<a name="line-350"></a>
<a name="line-351"></a>&gt; -- point :: Lens' Atom Point
<a name="line-352"></a>&gt; point :: Functor f =&gt; (Point -&gt; f Point) -&gt; Atom -&gt; f Atom
<a name="line-353"></a>&gt; point k atom = fmap (\newPoint -&gt; atom { _point = newPoint }) (k (_point atom))
<a name="line-354"></a>
<a name="line-355"></a>    This means that you can provide lenses for your library's types without
<a name="line-356"></a>    depending on the @lens@ library.  All you need is the `fmap` function,
<a name="line-357"></a>    which is provided by the Haskell Prelude.
<a name="line-358"></a>
<a name="line-359"></a>    /Question:/ How do I combine lenses?
<a name="line-360"></a>
<a name="line-361"></a>    /Answer:/ You compose them, using function composition (Yes, really!)
<a name="line-362"></a>
<a name="line-363"></a>    You can think of the function composition operator as having this type:
<a name="line-364"></a>
<a name="line-365"></a>&gt; (.) :: Lens' a b -&gt; Lens' b c -&gt; Lens' a c
<a name="line-366"></a>
<a name="line-367"></a>    We can compose lenses using function composition because `Lens'` is a
<a name="line-368"></a>    type synonym for a higher-order function:
<a name="line-369"></a>
<a name="line-370"></a>&gt; type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
<a name="line-371"></a>
<a name="line-372"></a>    So under the hood we are composing two higher-order functions to get back a
<a name="line-373"></a>    new higher-order function:
<a name="line-374"></a>
<a name="line-375"></a>&gt; (.) :: Functor f
<a name="line-376"></a>&gt;     =&gt; ((b -&gt; f b) -&gt; (a -&gt; f a))
<a name="line-377"></a>&gt;     -&gt; ((c -&gt; f c) -&gt; (b -&gt; f b))
<a name="line-378"></a>&gt;     -&gt; ((c -&gt; f c) -&gt; (a -&gt; f a))
<a name="line-379"></a>
<a name="line-380"></a>    In our original @Atom@ example, we composed the @point@ and @x@ lenses to
<a name="line-381"></a>    create a new composite lens:
<a name="line-382"></a>
<a name="line-383"></a>&gt; point     :: Lens' Atom Point
<a name="line-384"></a>&gt; x         :: Lens' Point Double
<a name="line-385"></a>&gt;
<a name="line-386"></a>&gt; point . x :: Lens' Atom Double
<a name="line-387"></a>
<a name="line-388"></a>    This composite lens lets us get or set the @x@ coordinate of an @Atom@.
<a name="line-389"></a>    We can use `over` and `view` on the composite `Lens'` and they will behave
<a name="line-390"></a>    exactly the way we expect:
<a name="line-391"></a>
<a name="line-392"></a>&gt; view (point . x) :: Atom -&gt; Double
<a name="line-393"></a>&gt;
<a name="line-394"></a>&gt; over (point . x) :: (Double -&gt; Double) -&gt; (Atom -&gt; Atom)
<a name="line-395"></a>
<a name="line-396"></a>    /Question:/ How do I consume lenses?
<a name="line-397"></a>
<a name="line-398"></a>    /Answer:/ Using `view`, `set` or `over`
<a name="line-399"></a>
<a name="line-400"></a>    Here are their types:
<a name="line-401"></a>
<a name="line-402"></a>&gt; view :: Lens' a b -&gt; a -&gt; b
<a name="line-403"></a>&gt;
<a name="line-404"></a>&gt; over :: Lens' a b -&gt; (b -&gt; b) -&gt; a -&gt; a
<a name="line-405"></a>&gt;
<a name="line-406"></a>&gt; set  :: Lens' a b -&gt;       b  -&gt; a -&gt; a
<a name="line-407"></a>&gt; set lens b = over lens (\_ -&gt; b)
<a name="line-408"></a>
<a name="line-409"></a>    `view` and `over` are the two fundamental functions on lenses.  `set` is
<a name="line-410"></a>    just a special case of `over`.
<a name="line-411"></a>
<a name="line-412"></a>    `view` and `over` are fundamental because they distribute over lens
<a name="line-413"></a>    composition:
<a name="line-414"></a>
<a name="line-415"></a>&gt; view (lens1 . lens2) = (view lens2) . (view lens1)
<a name="line-416"></a>&gt;
<a name="line-417"></a>&gt; view id = id
<a name="line-418"></a>
<a name="line-419"></a>&gt; over (lens1 . lens2) = (over lens1) . (over lens2)
<a name="line-420"></a>&gt;
<a name="line-421"></a>&gt; over id = id
<a name="line-422"></a>
<a name="line-423"></a>    /Question:/ What else do I need to know?
<a name="line-424"></a>
<a name="line-425"></a>    /Answer:/ That's pretty much it!
<a name="line-426"></a>
<a name="line-427"></a>    For 90% of use cases, you just:
<a name="line-428"></a>
<a name="line-429"></a>    * Create lenses (using `makeLens`, `lens` or plain-old `fmap`)
<a name="line-430"></a>
<a name="line-431"></a>    * Compose them (using (`.`))
<a name="line-432"></a>
<a name="line-433"></a>    * Consume them (using `view`, `set`, and `over`)
<a name="line-434"></a>
<a name="line-435"></a>    You could actually stop reading here if you are in a hurry since this
<a name="line-436"></a>    covers the overwhelmingly common use case for the library.  On the other
<a name="line-437"></a>    hand, keep reading if you would like to learn additional tricks and
<a name="line-438"></a>    features.
<a name="line-439"></a>-}</span>
<a name="line-440"></a>
<a name="line-441"></a><span class='hs-comment'>{- $accessors
<a name="line-442"></a>    You might be used to object-oriented languages where you could retrieve a
<a name="line-443"></a>    nested field using:
<a name="line-444"></a>
<a name="line-445"></a>&gt; atom.point.x
<a name="line-446"></a>
<a name="line-447"></a>    You can do almost the exact same thing using the @lens@ library, except
<a name="line-448"></a>    that the first dot will have a @^@ right before the dot:
<a name="line-449"></a>
<a name="line-450"></a>&gt; &gt;&gt;&gt; :load atom.hs
<a name="line-451"></a>&gt; &gt;&gt;&gt; let atom = Atom { _element = "C", _point = Point { _x = 1.0, _y = 2.0 } }
<a name="line-452"></a>&gt; &gt;&gt;&gt; atom^.point.x
<a name="line-453"></a>&gt; 1.0
<a name="line-454"></a>
<a name="line-455"></a>    You can better understand why this works, by adding whitespace and
<a name="line-456"></a>    explicit parentheses:
<a name="line-457"></a>
<a name="line-458"></a>&gt; atom ^. (point . x)
<a name="line-459"></a>
<a name="line-460"></a>    This trick uses (`^.`), which is an infix operator equivalent to `view`:
<a name="line-461"></a>
<a name="line-462"></a>&gt; (^.) :: a -&gt; Lens' a b -&gt; b
<a name="line-463"></a>&gt; x ^. l = view l x
<a name="line-464"></a>
<a name="line-465"></a>    ... and you just keep adding dots after that for each lens you compose.
<a name="line-466"></a>    This gives the appearance of object-oriented accessors if you omit the
<a name="line-467"></a>    whitespace around the operators.
<a name="line-468"></a>-}</span>
<a name="line-469"></a>
<a name="line-470"></a><span class='hs-comment'>{- $firstclass
<a name="line-471"></a>    Lenses are \"first class\" values, meaning that you can manipulate them
<a name="line-472"></a>    using ordinary functional programming techniques.  You can take them as
<a name="line-473"></a>    inputs, return them as outputs, or stick them in data structures.  Anything
<a name="line-474"></a>    goes!
<a name="line-475"></a>
<a name="line-476"></a>    For example, suppose we don't want to define separate shift functions for
<a name="line-477"></a>    @Atom@s and @Molecule@s:
<a name="line-478"></a>
<a name="line-479"></a>&gt; shiftAtomX :: Atom -&gt; Atom
<a name="line-480"></a>&gt; shiftAtomX = over (point . x) (+ 1)
<a name="line-481"></a>
<a name="line-482"></a>&gt; shiftMoleculeX :: Molecule -&gt; Molecule
<a name="line-483"></a>&gt; shiftMoleculeX = over (atoms . traverse . point . x) (+ 1)
<a name="line-484"></a>
<a name="line-485"></a>    We can instead unify them into a single function by parametrizing the
<a name="line-486"></a>    shift function on the lens:
<a name="line-487"></a>
<a name="line-488"></a>&gt; shift lens = over lens (+ 1)
<a name="line-489"></a>
<a name="line-490"></a>    This lets us write:
<a name="line-491"></a>
<a name="line-492"></a>&gt; shift (point . x) :: Atom -&gt; Atom
<a name="line-493"></a>&gt;
<a name="line-494"></a>&gt; shift (atoms . traverse . point . x) :: Molecule -&gt; Molecule
<a name="line-495"></a>
<a name="line-496"></a>    Even better, we can define synonyms for our composite lenses:
<a name="line-497"></a>
<a name="line-498"></a>&gt; atomX :: Lens' Atom Double
<a name="line-499"></a>&gt; atomX = point . x
<a name="line-500"></a>&gt;
<a name="line-501"></a>&gt; -- We'll learn what `Traversal` means shortly
<a name="line-502"></a>&gt; moleculeX :: Traversal' Molecule Double
<a name="line-503"></a>&gt; moleculeX = atoms . traverse . point . x
<a name="line-504"></a>
<a name="line-505"></a>    Now we can write code almost identical to the original code:
<a name="line-506"></a>
<a name="line-507"></a>&gt; shift atomX :: Atom -&gt; Atom
<a name="line-508"></a>&gt;
<a name="line-509"></a>&gt; shift moleculeX :: Molecule -&gt; Molecule
<a name="line-510"></a>
<a name="line-511"></a>    ... but we also get several other utilities for free:
<a name="line-512"></a>
<a name="line-513"></a>&gt; set atomX :: Double -&gt; Atom -&gt; Atom
<a name="line-514"></a>&gt;
<a name="line-515"></a>&gt; set moleculeX :: Double -&gt; Molecule -&gt; Molecule
<a name="line-516"></a>&gt;
<a name="line-517"></a>&gt; view atomX :: Atom -&gt; Double
<a name="line-518"></a>&gt;
<a name="line-519"></a>&gt; -- We can't use `view` for `Traversal'`s.  Read on to find out why
<a name="line-520"></a>&gt; toListOf moleculeX :: Molecule -&gt; [Double]
<a name="line-521"></a>
<a name="line-522"></a>    That's much more reusable, but you might wonder what this `Traversal'` and
<a name="line-523"></a>    `toListOf` business is all about.
<a name="line-524"></a>-}</span>
<a name="line-525"></a>
<a name="line-526"></a><span class='hs-comment'>-- $traversals</span>
<a name="line-527"></a><span class='hs-comment'>--     /Question:/ What is a traversal?</span>
<a name="line-528"></a><span class='hs-comment'>-- </span>
<a name="line-529"></a><span class='hs-comment'>--     /Answer:/ A first class getter and setter for an arbitrary number of values</span>
<a name="line-530"></a><span class='hs-comment'>-- </span>
<a name="line-531"></a><span class='hs-comment'>--     A traversal lets you get all the values it points to as a list and it also</span>
<a name="line-532"></a><span class='hs-comment'>--     lets you update or set all the values it points to.  Think of a traversal</span>
<a name="line-533"></a><span class='hs-comment'>--     as a record with two fields:</span>
<a name="line-534"></a><span class='hs-comment'>-- </span>
<a name="line-535"></a><span class='hs-comment'>-- &gt; data Traversal' a b = Traversal'</span>
<a name="line-536"></a><span class='hs-comment'>-- &gt;     { toListOf :: a -&gt; [b]</span>
<a name="line-537"></a><span class='hs-comment'>-- &gt;     , over     :: (b -&gt; b) -&gt; (a -&gt; a)</span>
<a name="line-538"></a><span class='hs-comment'>-- &gt;     }</span>
<a name="line-539"></a><span class='hs-comment'>-- </span>
<a name="line-540"></a><span class='hs-comment'>--     That's not how traversals are actually implemented, but it's a useful</span>
<a name="line-541"></a><span class='hs-comment'>--     starting intuition.</span>
<a name="line-542"></a><span class='hs-comment'>-- </span>
<a name="line-543"></a><span class='hs-comment'>--     We can still use `over` and `set` (a special case of `over`) with a</span>
<a name="line-544"></a><span class='hs-comment'>--     traversal, but instead of `view` we use `toListOf`.</span>
<a name="line-545"></a><span class='hs-comment'>-- </span>
<a name="line-546"></a><span class='hs-comment'>--     /Question:/ What is the type of a traversal?</span>
<a name="line-547"></a><span class='hs-comment'>-- </span>
<a name="line-548"></a><span class='hs-comment'>--     /Answer:/ We used one traversal in the above @Molecule@ example:</span>
<a name="line-549"></a><span class='hs-comment'>-- </span>
<a name="line-550"></a><span class='hs-comment'>-- &gt; moleculeX :: Traversal' Molecule Double</span>
<a name="line-551"></a><span class='hs-comment'>-- </span>
<a name="line-552"></a><span class='hs-comment'>--     This `Traversal'` lets us get or set an arbitrary number of x coordinates,</span>
<a name="line-553"></a><span class='hs-comment'>--     each of which is a `Double`.  There could be less than one x coordinate</span>
<a name="line-554"></a><span class='hs-comment'>--     (i.e. 0 coordinates) or more than one x coordinate.  Contrast this with a</span>
<a name="line-555"></a><span class='hs-comment'>--     `Lens'` which can only get or set exactly one value.</span>
<a name="line-556"></a><span class='hs-comment'>-- </span>
<a name="line-557"></a><span class='hs-comment'>--     Like `Lens'`, `Traversal'` is a type synonym for a higher-order function:</span>
<a name="line-558"></a><span class='hs-comment'>-- </span>
<a name="line-559"></a><span class='hs-comment'>-- &gt; type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</span>
<a name="line-560"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-561"></a><span class='hs-comment'>-- &gt; type Lens'      a b = forall f . Functor     f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</span>
<a name="line-562"></a><span class='hs-comment'>-- </span>
<a name="line-563"></a><span class='hs-comment'>--     Notice that the only difference between a `Lens'` and a `Traversal'` is the</span>
<a name="line-564"></a><span class='hs-comment'>--     type class constraint.  A `Lens'` has a `Functor` constraint and</span>
<a name="line-565"></a><span class='hs-comment'>--     `Traversal'` has an `Applicative` constraint.  This means that any `Lens'`</span>
<a name="line-566"></a><span class='hs-comment'>--     is automatically also a valid `Traversal'` (since `Functor` is a superclass</span>
<a name="line-567"></a><span class='hs-comment'>--     of `Applicative`).</span>
<a name="line-568"></a><span class='hs-comment'>-- </span>
<a name="line-569"></a><span class='hs-comment'>--     Since every `Lens'` is a `Traversal'`, all of our example lenses also</span>
<a name="line-570"></a><span class='hs-comment'>--     double as traversals:</span>
<a name="line-571"></a><span class='hs-comment'>-- </span>
<a name="line-572"></a><span class='hs-comment'>-- &gt; atoms   :: Traversal' Molecule [Atom]</span>
<a name="line-573"></a><span class='hs-comment'>-- &gt; element :: Traversal' Atom     String</span>
<a name="line-574"></a><span class='hs-comment'>-- &gt; point   :: Traversal' Atom     Point</span>
<a name="line-575"></a><span class='hs-comment'>-- &gt; x       :: Traversal' Point    Double</span>
<a name="line-576"></a><span class='hs-comment'>-- &gt; y       :: Traversal' Point    Double</span>
<a name="line-577"></a><span class='hs-comment'>-- </span>
<a name="line-578"></a><span class='hs-comment'>--     We actually used yet another `Traversal'`, which was `traverse` (from</span>
<a name="line-579"></a><span class='hs-comment'>--     "Data.Traversable"):</span>
<a name="line-580"></a><span class='hs-comment'>-- </span>
<a name="line-581"></a><span class='hs-comment'>-- &gt; traverse :: Traversable t =&gt; Traversal' (t a) a</span>
<a name="line-582"></a><span class='hs-comment'>-- </span>
<a name="line-583"></a><span class='hs-comment'>--     This works because the `Traversal'` type synonym expands out to:</span>
<a name="line-584"></a><span class='hs-comment'>-- </span>
<a name="line-585"></a><span class='hs-comment'>-- &gt; traverse :: (Applicative f, Traversable t) =&gt; (a -&gt; f a) -&gt; t a -&gt; f (t a)</span>
<a name="line-586"></a><span class='hs-comment'>-- </span>
<a name="line-587"></a><span class='hs-comment'>--     ... which is exactly the traditional type signature of `traverse`:</span>
<a name="line-588"></a><span class='hs-comment'>-- </span>
<a name="line-589"></a><span class='hs-comment'>--     In our @Molecule@ example, we were using the special case where @t = []@:</span>
<a name="line-590"></a><span class='hs-comment'>-- </span>
<a name="line-591"></a><span class='hs-comment'>-- &gt; traverse :: Traversal' [a] a</span>
<a name="line-592"></a><span class='hs-comment'>-- </span>
<a name="line-593"></a><span class='hs-comment'>--     In Haskell, you can derive `Functor`, `Data.Foldable.Foldable` and</span>
<a name="line-594"></a><span class='hs-comment'>--     `Traversable` for many data types using the @DeriveFoldable@ and</span>
<a name="line-595"></a><span class='hs-comment'>--     @DeriveTraversable@ extensions.  This means that you can autogenerate a</span>
<a name="line-596"></a><span class='hs-comment'>--     valid `traverse` for these data types:</span>
<a name="line-597"></a><span class='hs-comment'>-- </span>
<a name="line-598"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE DeriveFoldable    #-}</span>
<a name="line-599"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE DeriveFunctor     #-}</span>
<a name="line-600"></a><span class='hs-comment'>-- &gt; {-# LANGUAGE DeriveTraversable #-}</span>
<a name="line-601"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-602"></a><span class='hs-comment'>-- &gt; import Control.Lens</span>
<a name="line-603"></a><span class='hs-comment'>-- &gt; import Data.Foldable</span>
<a name="line-604"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-605"></a><span class='hs-comment'>-- &gt; data Pair a = Pair a a deriving (Functor, Foldable, Traversable)</span>
<a name="line-606"></a><span class='hs-comment'>-- </span>
<a name="line-607"></a><span class='hs-comment'>--     We could then use `traverse` to navigate from `Pair` to its two children:</span>
<a name="line-608"></a><span class='hs-comment'>-- </span>
<a name="line-609"></a><span class='hs-comment'>-- &gt; traverse :: Traversal' (Pair a) a</span>
<a name="line-610"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-611"></a><span class='hs-comment'>-- &gt; over traverse :: (a -&gt; a) -&gt; (Pair a -&gt; Pair a)</span>
<a name="line-612"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-613"></a><span class='hs-comment'>-- &gt; over traverse (+ 1) (Pair 3 4) = Pair 4 5</span>
<a name="line-614"></a><span class='hs-comment'>-- </span>
<a name="line-615"></a><span class='hs-comment'>--     /Question:/ How do I create traversals?</span>
<a name="line-616"></a><span class='hs-comment'>-- </span>
<a name="line-617"></a><span class='hs-comment'>--     /Answer:/ There are three main ways to create primitive traversals:</span>
<a name="line-618"></a><span class='hs-comment'>-- </span>
<a name="line-619"></a><span class='hs-comment'>--     * `traverse` is a `Traversal'` that you get for any type that implements</span>
<a name="line-620"></a><span class='hs-comment'>--       `Traversable`</span>
<a name="line-621"></a><span class='hs-comment'>-- </span>
<a name="line-622"></a><span class='hs-comment'>--     * Every `Lens'` will also type-check as a `Traversal'`</span>
<a name="line-623"></a><span class='hs-comment'>-- </span>
<a name="line-624"></a><span class='hs-comment'>--     * You can use Template Haskell to generate `Traversal'`s using `makePrisms`</span>
<a name="line-625"></a><span class='hs-comment'>--       since every `Prism'` is also a `Traversal'` (not covered in this</span>
<a name="line-626"></a><span class='hs-comment'>--       tutorial)</span>
<a name="line-627"></a><span class='hs-comment'>-- </span>
<a name="line-628"></a><span class='hs-comment'>--     /Question:/ How do I combine traversals?</span>
<a name="line-629"></a><span class='hs-comment'>-- </span>
<a name="line-630"></a><span class='hs-comment'>--     /Answer:/ You compose them, using function composition</span>
<a name="line-631"></a><span class='hs-comment'>-- </span>
<a name="line-632"></a><span class='hs-comment'>--     You can think of the function composition operator as having this type:</span>
<a name="line-633"></a><span class='hs-comment'>-- </span>
<a name="line-634"></a><span class='hs-comment'>-- &gt; (.) :: Traversal' a b -&gt; Traversal' b c -&gt; Traversal' a c</span>
<a name="line-635"></a><span class='hs-comment'>-- </span>
<a name="line-636"></a><span class='hs-comment'>--     We can compose traversals using function composition because a</span>
<a name="line-637"></a><span class='hs-comment'>--     `Traversal'` is a type synonym for a higher-order function:</span>
<a name="line-638"></a><span class='hs-comment'>-- </span>
<a name="line-639"></a><span class='hs-comment'>-- &gt; type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)</span>
<a name="line-640"></a><span class='hs-comment'>-- </span>
<a name="line-641"></a><span class='hs-comment'>--     So under the hood we are composing two functions to get back a new</span>
<a name="line-642"></a><span class='hs-comment'>--     function:</span>
<a name="line-643"></a><span class='hs-comment'>-- </span>
<a name="line-644"></a><span class='hs-comment'>-- &gt; (.) :: Applicative f</span>
<a name="line-645"></a><span class='hs-comment'>-- &gt;     =&gt; ((b -&gt; f b) -&gt; (a -&gt; f a))</span>
<a name="line-646"></a><span class='hs-comment'>-- &gt;     -&gt; ((c -&gt; f c) -&gt; (b -&gt; f b))</span>
<a name="line-647"></a><span class='hs-comment'>-- &gt;     -&gt; ((c -&gt; f c) -&gt; (a -&gt; f a))</span>
<a name="line-648"></a><span class='hs-comment'>-- </span>
<a name="line-649"></a><span class='hs-comment'>--     In our original @Molecule@ example, we composed four `Traversal'`s</span>
<a name="line-650"></a><span class='hs-comment'>--     together to create a new `Traversal'`:</span>
<a name="line-651"></a><span class='hs-comment'>-- </span>
<a name="line-652"></a><span class='hs-comment'>-- &gt; -- Remember that `atoms`, `point`, and `x` are also `Traversal'`s</span>
<a name="line-653"></a><span class='hs-comment'>-- &gt; atoms                        :: Traversal' Molecule [Atom]</span>
<a name="line-654"></a><span class='hs-comment'>-- &gt; traverse                     :: Traversal' [Atom]   Atom</span>
<a name="line-655"></a><span class='hs-comment'>-- &gt; point                        :: Traversal' Atom     Point</span>
<a name="line-656"></a><span class='hs-comment'>-- &gt; x                            :: Traversal' Point    Double</span>
<a name="line-657"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-658"></a><span class='hs-comment'>-- &gt; -- Now compose them</span>
<a name="line-659"></a><span class='hs-comment'>-- &gt; atoms                        :: Traversal' Molecule [Atom]</span>
<a name="line-660"></a><span class='hs-comment'>-- &gt; atoms . traverse             :: Traversal' Molecule Atom</span>
<a name="line-661"></a><span class='hs-comment'>-- &gt; atoms . traverse . point     :: Traversal' Molecule Point</span>
<a name="line-662"></a><span class='hs-comment'>-- &gt; atoms . traverse . point . x :: Traversal' Molecule Double</span>
<a name="line-663"></a><span class='hs-comment'>-- </span>
<a name="line-664"></a><span class='hs-comment'>--     This composite traversal lets us get or set the @x@ coordinates of a</span>
<a name="line-665"></a><span class='hs-comment'>--     @Molecule@.</span>
<a name="line-666"></a><span class='hs-comment'>-- </span>
<a name="line-667"></a><span class='hs-comment'>-- &gt; over (atoms . traverse . point . x)</span>
<a name="line-668"></a><span class='hs-comment'>-- &gt;     :: (Double -&gt; Double) -&gt; (Molecule -&gt; Molecule)</span>
<a name="line-669"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-670"></a><span class='hs-comment'>-- &gt; toListOf (atoms . traverse . point . x) :: Molecule -&gt; [Double]</span>
<a name="line-671"></a><span class='hs-comment'>-- </span>
<a name="line-672"></a><span class='hs-comment'>--     /Question:/ How do I consume traversals?</span>
<a name="line-673"></a><span class='hs-comment'>-- </span>
<a name="line-674"></a><span class='hs-comment'>--     /Answer:/ Using `toListOf`, `set` or `over`</span>
<a name="line-675"></a><span class='hs-comment'>-- </span>
<a name="line-676"></a><span class='hs-comment'>--     Here are their types:</span>
<a name="line-677"></a><span class='hs-comment'>-- </span>
<a name="line-678"></a><span class='hs-comment'>-- &gt; toListOf :: Lens' a b -&gt; a -&gt; [b]</span>
<a name="line-679"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-680"></a><span class='hs-comment'>-- &gt; over :: Traversal' a b -&gt; (b -&gt; b) -&gt; a -&gt; a</span>
<a name="line-681"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-682"></a><span class='hs-comment'>-- &gt; set  :: Traversal' a b -&gt;       b  -&gt; a -&gt; a</span>
<a name="line-683"></a><span class='hs-comment'>-- &gt; set traversal b = over traversal (\_ -&gt; b)</span>
<a name="line-684"></a><span class='hs-comment'>--</span>
<a name="line-685"></a><span class='hs-comment'>--     `toListOf` distributes over traversal composition:</span>
<a name="line-686"></a><span class='hs-comment'>-- </span>
<a name="line-687"></a><span class='hs-comment'>-- &gt; toListOf (traversal1 . traversal2) = (toListOf traversal1) &gt;=&gt; (toListOf traversal2)</span>
<a name="line-688"></a><span class='hs-comment'>-- &gt;</span>
<a name="line-689"></a><span class='hs-comment'>-- &gt; toListOf id = return</span>
<a name="line-690"></a><span class='hs-comment'>--</span>
<a name="line-691"></a><span class='hs-comment'>-- You can also use (`^..`), which is an infix operator equivalent to</span>
<a name="line-692"></a><span class='hs-comment'>-- `toListOf`:</span>
<a name="line-693"></a><span class='hs-comment'>--</span>
<a name="line-694"></a><span class='hs-comment'>-- &gt; &gt;&gt;&gt; Pair 3 4 ^.. traverse</span>
<a name="line-695"></a><span class='hs-comment'>-- &gt; [3,4]</span>
<a name="line-696"></a>
<a name="line-697"></a><span class='hs-comment'>{- $types
<a name="line-698"></a>    You might wonder why you can use `over` on both a `Lens'` and a
<a name="line-699"></a>    `Traversal'` but you can only use `view` on a `Lens'`.  We can see why by
<a name="line-700"></a>    studying the (simplified) type and implementation of `over`:
<a name="line-701"></a>
<a name="line-702"></a>&gt; over :: ((b -&gt; Identity b) -&gt; (a -&gt; Identity b)) -&gt; (b -&gt; b) -&gt; a -&gt; a
<a name="line-703"></a>&gt; over setter f x = runIdentity (setter (\y -&gt; Identity (f y)) x)
<a name="line-704"></a>
<a name="line-705"></a>    To follow the implementation, just step slowly through the types:
<a name="line-706"></a>
<a name="line-707"></a>&gt; setter :: (b -&gt; Identity b) -&gt; (a -&gt; Identity b)
<a name="line-708"></a>&gt; f      :: b -&gt; b
<a name="line-709"></a>&gt; x      :: a
<a name="line-710"></a>
<a name="line-711"></a>&gt;                      \y -&gt; Identity (f y)     :: b -&gt; Identity b
<a name="line-712"></a>&gt;              setter (\y -&gt; Identity (f y))    :: a -&gt; Identity a
<a name="line-713"></a>&gt;              setter (\y -&gt; Identity (f y)) x  ::      Identity a
<a name="line-714"></a>&gt; runIdentity (setter (\y -&gt; Identity (f y)) x) ::               a
<a name="line-715"></a>
<a name="line-716"></a>     We can replace @setter@ with @point@ and replace @x@ with @atom@ to see
<a name="line-717"></a>     that this generates the correct code for updating an atom's point:
<a name="line-718"></a>
<a name="line-719"></a>&gt;   over point f atom
<a name="line-720"></a>&gt;
<a name="line-721"></a>&gt; -- Definition of `over`
<a name="line-722"></a>&gt; = runIdentity (point (\y -&gt; Identity (f y)) atom)
<a name="line-723"></a>&gt;
<a name="line-724"></a>&gt; -- Definition of `point`
<a name="line-725"></a>&gt; = runIdentity (fmap (\newPoint -&gt; atom { _point = newPoint }) (Identity (f (_point atom)))
<a name="line-726"></a>&gt;
<a name="line-727"></a>&gt; -- fmap g (Identity y) = Identity (g y)
<a name="line-728"></a>&gt; = runIdentity (Identity (atom { _point = f (_point atom) }))
<a name="line-729"></a>&gt;
<a name="line-730"></a>&gt; -- runIdentity (Identity z) = z
<a name="line-731"></a>&gt; = atom { _point = f (_point atom) }
<a name="line-732"></a>
<a name="line-733"></a>    ... which is exactly what we would have written by hand without lenses.
<a name="line-734"></a>
<a name="line-735"></a>    The reason `over` works for both `Lens'`es and `Traversal'`s is because
<a name="line-736"></a>    `Identity` implements both `Functor` and `Applicative`:
<a name="line-737"></a>
<a name="line-738"></a>&gt; instance Functor     Identity where ...
<a name="line-739"></a>&gt; instance Applicative Identity where ...
<a name="line-740"></a>
<a name="line-741"></a>    So both the `Lens'` type and `Traversal'` type synonyms:
<a name="line-742"></a>
<a name="line-743"></a>&gt; type Traversal' a b = forall f . Applicative f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
<a name="line-744"></a>&gt;
<a name="line-745"></a>&gt; type Lens'      a b = forall f . Functor     f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
<a name="line-746"></a>
<a name="line-747"></a>    ... can be specialized to use `Identity` in place of @f@:
<a name="line-748"></a>
<a name="line-749"></a>&gt; (b -&gt; Identity b) -&gt; (a -&gt; Identity a)
<a name="line-750"></a>
<a name="line-751"></a>    ... making them valid arguments to `over`.
<a name="line-752"></a>
<a name="line-753"></a>    Now let's study the (simplified) type and implementation of `view`:
<a name="line-754"></a>
<a name="line-755"></a>&gt; view :: ((b -&gt; Const b b) -&gt; (a -&gt; Const b a)) -&gt; a -&gt; b
<a name="line-756"></a>&gt; view getter x = getConst (getter Const x)
<a name="line-757"></a>
<a name="line-758"></a>    Again, we can walk slowly through the types:
<a name="line-759"></a>
<a name="line-760"></a>&gt; getter :: (b -&gt; Const b b) -&gt; (a -&gt; Const b a)
<a name="line-761"></a>&gt; x      :: a
<a name="line-762"></a>
<a name="line-763"></a>&gt; getter Const              :: a -&gt; Const b a
<a name="line-764"></a>&gt; getter Const x            ::      Const b a
<a name="line-765"></a>&gt; getConst (getter Const x) ::            b
<a name="line-766"></a>
<a name="line-767"></a>    Let's see how this plays out for the @point@ lens:
<a name="line-768"></a>
<a name="line-769"></a>&gt;   view point atom
<a name="line-770"></a>&gt;
<a name="line-771"></a>&gt; -- Definition of `view`
<a name="line-772"></a>&gt; = getConst (point Const atom)
<a name="line-773"></a>&gt; 
<a name="line-774"></a>&gt; -- Definition of `point`
<a name="line-775"></a>&gt; = getConst (fmap (\newPoint -&gt; atom { _point = newPoint }) (Const (_point atom)))
<a name="line-776"></a>&gt;
<a name="line-777"></a>&gt; -- fmap g (Const y) = Const y
<a name="line-778"></a>&gt; = getConst (Const (_point atom))
<a name="line-779"></a>&gt;
<a name="line-780"></a>&gt; -- getConst (Const z) = z
<a name="line-781"></a>&gt; = _point atom
<a name="line-782"></a>
<a name="line-783"></a>    ... which is exactly what we would have written by hand without lenses.
<a name="line-784"></a>
<a name="line-785"></a>    `view` accepts `Lens'`es because `Const` implements `Functor`:
<a name="line-786"></a>
<a name="line-787"></a>&gt; instance Functor (Const b)
<a name="line-788"></a>
<a name="line-789"></a>    ... so the `Lens'` type synonym:
<a name="line-790"></a>
<a name="line-791"></a>
<a name="line-792"></a>&gt; type Lens' a b = forall f . Functor f =&gt; (b -&gt; f b) -&gt; (a -&gt; f a)
<a name="line-793"></a>
<a name="line-794"></a>    ... can be specialized to use @(`Const` b)@ in place of @f@:
<a name="line-795"></a>
<a name="line-796"></a>&gt; (b -&gt; Const b b) -&gt; (a -&gt; Const b b)
<a name="line-797"></a>
<a name="line-798"></a>
<a name="line-799"></a>    ... making it a valid argument to `view`.
<a name="line-800"></a>
<a name="line-801"></a>    Interestingly, `Const` implements also `Applicative`, but with a
<a name="line-802"></a>    constraint:
<a name="line-803"></a>
<a name="line-804"></a>&gt; instance Monoid b =&gt; Applicative (Const b)
<a name="line-805"></a>
<a name="line-806"></a>    This implies that we *can* use `view` on a `Traversal'`, but only if the
<a name="line-807"></a>    value that we extract is a `Monoid`.  Let's try this out:
<a name="line-808"></a>
<a name="line-809"></a>&gt; &gt;&gt;&gt; :load atom.hs
<a name="line-810"></a>&gt; &gt;&gt;&gt; let atom1 = Atom { _element = "C", _point = Point { _x = 1.0, _y = 2.0 } }
<a name="line-811"></a>&gt; &gt;&gt;&gt; let atom2 = Atom { _element = "O", _point = Point { _x = 3.0, _y = 4.0 } }
<a name="line-812"></a>&gt; &gt;&gt;&gt; let molecule = Molecule { _atoms = [atom1, atom2] }
<a name="line-813"></a>&gt; &gt;&gt;&gt; view (atoms . traverse . element) molecule
<a name="line-814"></a>&gt; "CO"
<a name="line-815"></a>
<a name="line-816"></a>    This works because our traversal's result is a `String`:
<a name="line-817"></a>
<a name="line-818"></a>&gt; atoms . traverse . element :: Traversal' Molecule String
<a name="line-819"></a>
<a name="line-820"></a>    ... and `String` implements the `Data.Monoid.Monoid` interface.  When you
<a name="line-821"></a>    try to extract multiple strings using `view` they get flattened together
<a name="line-822"></a>    into a single `String` using `Data.Monoid.mappend`.
<a name="line-823"></a>
<a name="line-824"></a>    If you try to extract the element from an empty molecule:
<a name="line-825"></a>
<a name="line-826"></a>&gt; &gt;&gt;&gt; view (atoms . traverse . element) (Molecule { _atoms = [] })
<a name="line-827"></a>&gt; ""
<a name="line-828"></a>
<a name="line-829"></a>    You get the empty string (i.e. `Data.Monoid.mempty`).
<a name="line-830"></a>
<a name="line-831"></a>    This is why the result of a `Traversal'` needs to be a `Data.Monoid.Monoid`
<a name="line-832"></a>    when using `view`.  If the `Traversal'` points to more than one value you
<a name="line-833"></a>    need some way to combine them into a single value (using
<a name="line-834"></a>    `Data.Monoid.mappend`) and if the `Traversal'` points to less than one
<a name="line-835"></a>    value you need a default value to return (using `Data.Monoid.mempty`).
<a name="line-836"></a>
<a name="line-837"></a>    If you try to `view` a `Traversal'` that doesn't point to a
<a name="line-838"></a>    `Data.Monoid.Monoid`, you will get the following type error:
<a name="line-839"></a>
<a name="line-840"></a>&gt; &gt;&gt;&gt; view (atoms . traverse . point . x) molecule
<a name="line-841"></a>&gt;     No instance for (Data.Monoid.Monoid Double)
<a name="line-842"></a>&gt;       arising from a use of `traverse'
<a name="line-843"></a>&gt;     Possible fix:
<a name="line-844"></a>&gt;       add an instance declaration for (Data.Monoid.Monoid Double)
<a name="line-845"></a>&gt;     In the first argument of `(.)', namely `traverse'
<a name="line-846"></a>&gt;     In the second argument of `(.)', namely `traverse . point . x'
<a name="line-847"></a>&gt;     In the first argument of `view', namely
<a name="line-848"></a>&gt;       `(atoms . traverse . point . x)'
<a name="line-849"></a>
<a name="line-850"></a>    The compiler complains that `Double` does not implement the
<a name="line-851"></a>    `Data.Monoid.Monoid` type class, so there is no sensible way to merge all
<a name="line-852"></a>    the x coordinates that our `Traversal'` points to.  For these cases you
<a name="line-853"></a>    should use `toListOf` instead.
<a name="line-854"></a>-}</span>
<a name="line-855"></a>
<a name="line-856"></a><span class='hs-comment'>{- $drawbacks
<a name="line-857"></a>    Lenses come with trade-offs, so you should use them wisely.
<a name="line-858"></a>
<a name="line-859"></a>    For example, lenses do not produce the best error messages.  Unless you
<a name="line-860"></a>    understand how `Traversal'`s work you will probably not understand this
<a name="line-861"></a>    error message:
<a name="line-862"></a>
<a name="line-863"></a>&gt; &gt;&gt;&gt; view (atoms . traverse . point . x) molecule
<a name="line-864"></a>&gt;     No instance for (Data.Monoid.Monoid Double)
<a name="line-865"></a>&gt;       arising from a use of `traverse'
<a name="line-866"></a>&gt;     Possible fix:
<a name="line-867"></a>&gt;       add an instance declaration for (Data.Monoid.Monoid Double)
<a name="line-868"></a>&gt;     In the first argument of `(.)', namely `traverse'
<a name="line-869"></a>&gt;     In the second argument of `(.)', namely `traverse . point . x'
<a name="line-870"></a>&gt;     In the first argument of `view', namely
<a name="line-871"></a>&gt;       `(atoms . traverse . point . x)'
<a name="line-872"></a>
<a name="line-873"></a>    Also, lenses increase the learning curve for new Haskell programmers, so
<a name="line-874"></a>    you should consider avoiding them in tutorial code targeting novice
<a name="line-875"></a>    Haskell programmers.
<a name="line-876"></a>
<a name="line-877"></a>    Lenses also add a level of boilerplate to all data types to auto-generate
<a name="line-878"></a>    lenses and increase compile times.  So for small projects the overhead of
<a name="line-879"></a>    adding lenses may dwarf the benefits.
<a name="line-880"></a>
<a name="line-881"></a>    @lens@ is also a library with a large dependency tree.  If you need a
<a name="line-882"></a>    more light-weight alternative you can use the @lens-simple@ library which
<a name="line-883"></a>    provides a restricted subset of this library with a much smaller dependency
<a name="line-884"></a>    tree.  In contrast, this @lens@ library focuses on being \"batteries
<a name="line-885"></a>    included\" and significantly more general.
<a name="line-886"></a>
<a name="line-887"></a>    The ideal use case for the @lens@ library is a large project with rich and
<a name="line-888"></a>    deeply nested types.  In these large projects the benefits of using lenses
<a name="line-889"></a>    outweigh the costs.
<a name="line-890"></a>-}</span>
<a name="line-891"></a>
<a name="line-892"></a><span class='hs-comment'>{- $conclusion
<a name="line-893"></a>    This tutorial covers an extremely small subset of this library.  If you
<a name="line-894"></a>    would like to learn more, you can begin by skimming the example code in the
<a name="line-895"></a>    following modules:
<a name="line-896"></a>
<a name="line-897"></a>    * "Control.Lens.Getter"
<a name="line-898"></a>
<a name="line-899"></a>    * "Control.Lens.Setter"
<a name="line-900"></a>
<a name="line-901"></a>    * "Control.Lens.Traversal"
<a name="line-902"></a>
<a name="line-903"></a>    * "Control.Lens.Tuple"
<a name="line-904"></a>
<a name="line-905"></a>    * "Control.Lens.Lens"
<a name="line-906"></a>
<a name="line-907"></a>    * "Control.Lens.Review"
<a name="line-908"></a>
<a name="line-909"></a>    * "Control.Lens.Prism"
<a name="line-910"></a>
<a name="line-911"></a>    * "Control.Lens.Iso"
<a name="line-912"></a>
<a name="line-913"></a>    The documentation for these modules includes several examples to get you
<a name="line-914"></a>    started and help you build an intuition for more advanced tricks.
<a name="line-915"></a>
<a name="line-916"></a>    You can also study several long-form examples here:
<a name="line-917"></a>
<a name="line-918"></a>    &lt;https://github.com/ekmett/lens/tree/master/examples&gt;
<a name="line-919"></a>
<a name="line-920"></a>    If you would like a broader survey of lens features, then you can check
<a name="line-921"></a>    out these tutorials:
<a name="line-922"></a>
<a name="line-923"></a>    * &lt;https://www.fpcomplete.com/school/to-infinity-and-beyond/pick-of-the-week/a-little-lens-starter-tutorial A little lens starter tutorial&gt; - Introduces
<a name="line-924"></a>Prisms, Isos and JSON functionality
<a name="line-925"></a>
<a name="line-926"></a>    * &lt;<a href="http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html">http://www.haskellforall.com/2013/05/program-imperatively-using-haskell.html</a> Program imperatively using Haskell lenses&gt; - Illustrates lens support for stateful code
<a name="line-927"></a>-}</span>
</pre></body>
</html>
